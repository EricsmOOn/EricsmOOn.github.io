<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Java 基础 | Eric's Moon</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java 基础</h1><a id="logo" href="/.">Eric's Moon</a><p class="description">为往圣继绝学 为万世开太平</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/friends/"><i class="fa fa-link"> 朋友</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java 基础</h1><div class="post-meta">May 7, 2019<span> | </span><span class="category"><a href="/categories/计算机/">计算机</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 4.4k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 16</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" data-disqus-identifier="post/javaBase/" href="/post/javaBase/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java基础"><span class="toc-number">1.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java的四种引用方式"><span class="toc-number">1.1.</span> <span class="toc-text">Java的四种引用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#强引用（StrongReference）"><span class="toc-number">1.1.1.</span> <span class="toc-text">强引用（StrongReference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#软引用（SoftReference）"><span class="toc-number">1.1.2.</span> <span class="toc-text">软引用（SoftReference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#弱引用（WeakReference）"><span class="toc-number">1.1.3.</span> <span class="toc-text">弱引用（WeakReference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚引用（PhantomReference）"><span class="toc-number">1.1.4.</span> <span class="toc-text">虚引用（PhantomReference）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java的垃圾回收机制"><span class="toc-number">1.2.</span> <span class="toc-text">Java的垃圾回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java的类反射机制"><span class="toc-number">1.3.</span> <span class="toc-text">Java的类反射机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-forName-对比"><span class="toc-number">1.3.1.</span> <span class="toc-text">Class.forName( )对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类反射代码详解"><span class="toc-number">1.3.2.</span> <span class="toc-text">类反射代码详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java重要关键字"><span class="toc-number">1.4.</span> <span class="toc-text">Java重要关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#访问控制"><span class="toc-number">1.4.1.</span> <span class="toc-text">访问控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#private"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">private</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#protected"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">protected</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#public"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">public</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类-方法-变量修饰符"><span class="toc-number">1.4.2.</span> <span class="toc-text">类 方法 变量修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#abstract"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">abstract</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#extends"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">extends</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">final</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#implements"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">implements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#interface"><span class="toc-number">1.4.2.6.</span> <span class="toc-text">interface</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#native"><span class="toc-number">1.4.2.7.</span> <span class="toc-text">native</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static"><span class="toc-number">1.4.2.8.</span> <span class="toc-text">static</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strictfp"><span class="toc-number">1.4.2.9.</span> <span class="toc-text">strictfp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized"><span class="toc-number">1.4.2.10.</span> <span class="toc-text">synchronized</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量引用"><span class="toc-number">1.4.3.</span> <span class="toc-text">变量引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#super"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">super</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#void"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">void</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#保留字"><span class="toc-number">1.4.4.</span> <span class="toc-text">保留字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#goto"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">goto</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">const</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-IO"><span class="toc-number">1.5.</span> <span class="toc-text">Java.IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-io-File"><span class="toc-number">1.5.1.</span> <span class="toc-text">java.io.File</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#public-File-String-pathname"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">public File(String pathname)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#public-File-String-parent-String-child"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">public File(String parent,String child)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#流的分类"><span class="toc-number">1.5.2.</span> <span class="toc-text">流的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件流"><span class="toc-number">1.5.3.</span> <span class="toc-text">文件流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#读取文件"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">读取文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#写入文件"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">写入文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓冲流"><span class="toc-number">1.5.4.</span> <span class="toc-text">缓冲流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转换流"><span class="toc-number">1.5.5.</span> <span class="toc-text">转换流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标准输入输出流"><span class="toc-number">1.5.6.</span> <span class="toc-text">标准输入输出流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象流"><span class="toc-number">1.5.7.</span> <span class="toc-text">对象流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#序列化"><span class="toc-number">1.5.7.1.</span> <span class="toc-text">序列化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-集合类"><span class="toc-number">1.6.</span> <span class="toc-text">Java 集合类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-锁"><span class="toc-number">1.7.</span> <span class="toc-text">Java 锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#乐观锁"><span class="toc-number">1.7.1.</span> <span class="toc-text">乐观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#悲观锁"><span class="toc-number">1.7.2.</span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#公平锁-非公平锁"><span class="toc-number">1.7.3.</span> <span class="toc-text">公平锁/非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#偏向锁-轻量级锁-重量级锁"><span class="toc-number">1.7.4.</span> <span class="toc-text">偏向锁/轻量级锁/重量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized"><span class="toc-number">1.7.5.</span> <span class="toc-text">Synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReenTrantLock"><span class="toc-number">1.7.6.</span> <span class="toc-text">ReenTrantLock</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="Java的四种引用方式"><a href="#Java的四种引用方式" class="headerlink" title="Java的四种引用方式"></a>Java的四种引用方式</h2><p>因为值类型存储于Stack里，引用类型存储于Heap里，但是在Stack里有指向Heap的引用。</p>
<blockquote>
<p>Java简单数据类型没有String。</p>
<p>简单数据类型具有栈共享。<code>int a = 3;int b = 3;</code>那么a和都储存在 栈里且指向同一个字面值3。但是对a,b的分别修改是不会导致对方数值的变化。</p>
</blockquote>
<p>Java的简单数据类型作为参数时传递的是值（Pass by Value），在函数中使用的是源变量的拷贝，对源变量不产生影响。</p>
<p>引用是一种数据类型（保存在stack），保存了对象在内存（heap）中的地址，这种类型即不是我们平时所说的简单数据类型也不是类实例(对象)。</p>
<h3 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h3><p> 是指创建一个对象并把这个对象赋给一个引用变量。</p>
<p>比如：</p>
<p><code>Object object = new Object();</code></p>
<p><code>String str = &quot;hello&quot;;</code></p>
<h3 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建对象强引用</span></span><br><span class="line">MyObject aRef = <span class="keyword">new</span>  MyObject();  </span><br><span class="line"><span class="comment">//参数调用</span></span><br><span class="line">SoftReference aSoftRef=<span class="keyword">new</span> SoftReference(aRef);</span><br><span class="line"><span class="comment">//结束强引用 为软引用</span></span><br><span class="line">aRef = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<h3 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用java.lang.ref.WeakReference类来表示。</span></span><br><span class="line"><span class="comment">//创建弱引用对象</span></span><br><span class="line">WeakReference&lt;People&gt; reference=<span class="keyword">new</span> WeakReference&lt;People&gt;(<span class="keyword">new</span> People(<span class="string">"zhangsan"</span>));</span><br><span class="line"><span class="comment">//一旦gc执行则马上被回收</span></span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊情况</span></span><br><span class="line"><span class="comment">//关联强引用</span></span><br><span class="line">People people=<span class="keyword">new</span> People(<span class="string">"zhangsan"</span>);  </span><br><span class="line">WeakReference&lt;People&gt;reference=<span class="keyword">new</span> WeakReference&lt;People&gt;(people);</span><br><span class="line"><span class="comment">//不会回收</span></span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure>
<h3 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用java.lang.ref.PhantomReference类来表示。</span></span><br><span class="line"><span class="comment">//虚引用必须和引用队列关联使用。</span></span><br><span class="line"><span class="comment">//只要进行垃圾回收，虚引用就会被回收。</span></span><br><span class="line">ReferenceQueue&lt;String&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;String&gt;();  </span><br><span class="line">PhantomReference&lt;String&gt; pr = <span class="keyword">new</span> PhantomReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"hello"</span>), queue);</span><br></pre></td></tr></table></figure>
<p>垃圾回收顺序为 虚引用—&gt;弱引用—&gt;软引用—&gt;强引用。</p>
<p>弱引用在没有强引用被执行gc时马上回收。软引用在没有强引用且<strong>内存不足</strong>被执行gc时回收。</p>
<h2 id="Java的垃圾回收机制"><a href="#Java的垃圾回收机制" class="headerlink" title="Java的垃圾回收机制"></a>Java的垃圾回收机制</h2><blockquote>
<p>垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。</p>
<blockquote>
<p><strong><em>内存泄露</em></strong>是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为<strong>对象游离</strong>。</p>
</blockquote>
</blockquote>
<h2 id="Java的类反射机制"><a href="#Java的类反射机制" class="headerlink" title="Java的类反射机制"></a>Java的类反射机制</h2><p><strong>.getClass( ) .class Class.forName( )</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一种方式获取Class对象(有对象反射多此一举)</span></span><br><span class="line">    Student stu1 = <span class="keyword">new</span> Student();<span class="comment">//这一new 产生一个Student对象，一个Class对象。</span></span><br><span class="line">    Class stuClass = stu1.getClass();<span class="comment">//获取Class对象</span></span><br><span class="line">    System.out.println(stuClass.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种方式获取Class对象(需要导入类包依赖性太强)</span></span><br><span class="line">    Class stuClass2 = Student.class;</span><br><span class="line">    System.out.println(stuClass == stuClass2);<span class="comment">//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种方式获取Class对象(推荐使用)</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class stuClass3 = Class.forName(<span class="string">"fanshe.Student"</span>);<span class="comment">//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名</span></span><br><span class="line">        System.out.println(stuClass3 == stuClass2);<span class="comment">//判断三种方式是否获取的是同一个Class对象</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Class-forName-对比"><a href="#Class-forName-对比" class="headerlink" title="Class.forName( )对比"></a>Class.forName( )对比</h3><blockquote>
<p><em>Class.forName( )</em>和<em>ClassLoader.loadClass( )</em>的<strong>区别</strong>:</p>
<p>Class.forName( )默认<strong>初始化</strong>执行static方法。</p>
</blockquote>
<h3 id="类反射代码详解"><a href="#类反射代码详解" class="headerlink" title="类反射代码详解"></a>类反射代码详解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类加载</span></span><br><span class="line">Class clazz = Class.forName(<span class="string">"fanshe.Student"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射获取构造方法</span></span><br><span class="line"><span class="comment">//获取所有公有构造方法</span></span><br><span class="line">Constructor[] conArray = clazz.getConstructors();</span><br><span class="line"><span class="comment">//所有构造方法</span></span><br><span class="line">clazz.getDeclaredConstructors();</span><br><span class="line"><span class="comment">//所有公有无参</span></span><br><span class="line">clazz.getConstructor(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Class.newInstance()和Class.Constructor.newInstance()的区别</span></span><br><span class="line">Class.newInstance() <span class="comment">//只能够调用无参的构造函数，即默认的构造函数； </span></span><br><span class="line">Constructor.newInstance() <span class="comment">//可以根据传入的参数，调用任意构造构造函数。 </span></span><br><span class="line"></span><br><span class="line">Class.newInstance() <span class="comment">//抛出所有由被调用构造函数抛出的异常。 </span></span><br><span class="line"></span><br><span class="line">Class.newInstance() <span class="comment">//要求被调用的构造函数是可见的，也即必须是public类型的; </span></span><br><span class="line">Constructor.newInstance() <span class="comment">//在特定的情况下，可以调用私有的构造函数。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//反射获取成员变量</span></span><br><span class="line">.getFields()</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射获取方法</span></span><br><span class="line">Method m = clazz.getMethods(<span class="string">"方法名"</span>,String.class)<span class="comment">//第二个参数是原方法形参</span></span><br><span class="line"><span class="comment">//实例化一个Student对象</span></span><br><span class="line">Object obj = claszz.getConstructor().newInstance();</span><br><span class="line"><span class="comment">//反射调用方法</span></span><br><span class="line">m.invoke(obj, <span class="string">"方法参数"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Java重要关键字"><a href="#Java重要关键字" class="headerlink" title="Java重要关键字"></a>Java重要关键字</h2><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* 成员变量/方法的访问权限</span><br><span class="line"></span><br><span class="line">*                                        <span class="keyword">private</span>        <span class="keyword">default</span>        <span class="keyword">protected</span>       <span class="keyword">public</span></span><br><span class="line"></span><br><span class="line">* 自己包自己类                                √              √               √              √</span><br><span class="line"></span><br><span class="line">* 自己包别的类                                               √               √              √</span><br><span class="line"></span><br><span class="line">* 别的包别的类有继承关系②                                                     ①             √</span><br><span class="line"></span><br><span class="line">* 别的包别的类无继承关系                                                                     √</span><br><span class="line"></span><br><span class="line">①：子类可以继承，但是不能访问父类的成员变量/方法（一般来说，可以访问就可以继承）。</span><br><span class="line"></span><br><span class="line">②：有继承关系说明访问对象所在的类是父类。</span><br></pre></td></tr></table></figure>
<h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p>只能在声明 private（内部）类、方法或字段的类中引用这些类、方法或字段。在类的外部或者对于子类而言，它们是不可见的。 所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。</p>
<h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><p>可以在声明 protected 类、方法或字段的类、同一个包中的其他任何类以及任何子类（无论子类是在哪个包中声明的）中引用这些类、方法或字段。所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。</p>
<h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><p>可能只会在其他任何类或包中引用 public 类、方法或字段。所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。</p>
<h3 id="类-方法-变量修饰符"><a href="#类-方法-变量修饰符" class="headerlink" title="类 方法 变量修饰符"></a>类 方法 变量修饰符</h3><h4 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h4><ul>
<li>不能直接实例化。</li>
<li>方法不在声明它的类中实现，但必须在某个子类中重写。</li>
<li>采用 abstract 方法的类是抽象类，必须声明为abstract。</li>
</ul>
<h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><ul>
<li>用来声明新的类，该类是相关变量和/或方法的集合。</li>
<li>类是对象的模板，每个对象都是类的一个实例。</li>
<li>要使用类，通常使用 new 操作符将类的对象实例化，然后调用类的方法来访问类的功能。</li>
</ul>
<h4 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h4><ul>
<li>用在 class 或 interface 声明中，用于指示所声明的类或接口是子类。</li>
<li>子类继承父类的所有 public 和 protected 变量和方法。 </li>
<li>子类可以重写父类的任何非 final 方法。</li>
</ul>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><ul>
<li>可以应用于类，以指示不能扩展该类（不能有子类）。</li>
<li>final 关键字可以应用于方法，以指示在子类中不能重写此方法。</li>
<li>一个类不能同时是 abstract 又是 final。abstract 意味着必须扩展类，final 意味着不能扩展类。abstract 意味着必须重写方法，final 意味着不能重写方法。</li>
</ul>
<h4 id="implements"><a href="#implements" class="headerlink" title="implements"></a>implements</h4><ul>
<li>在 class 声明中使用，以指示所声明的类提供了指定的接口中所声明的所有方法的实现。</li>
<li>类必须提供在接口中所声明的所有方法的实现。</li>
<li>一个类可以实现多个接口。</li>
</ul>
<h4 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h4><ul>
<li>用来声明新的 Java 接口，接口是方法的集合。</li>
<li>接口是 Java 语言的一项强大功能。任何类都可声明它实现一个或多个接口，这意味着它实现了在这些接口中所定义的所有方法。 </li>
<li>实现了接口的任何类都必须提供在该接口中的所有方法的实现。一个类可以实现多个接口。</li>
</ul>
<h4 id="native"><a href="#native" class="headerlink" title="native"></a>native</h4><ul>
<li>可以应用于方法，以指示该方法是用 Java 以外的语言实现的。</li>
</ul>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ul>
<li>static 关键字可以应用于内部类（在另一个类中定义的类）、方法或字段（类的成员变量）。 </li>
<li>意味着应用它的实体在声明该实体的类的任何特定实例外部可用。</li>
<li>static 字段（类的成员变量）在类的所有实例中只存在一次。 </li>
<li>可以从类的外部调用 static 方法，而不用首先实例化该类。</li>
<li>这样的引用始终包括类名作为方法调用的限定符。</li>
</ul>
<h4 id="strictfp"><a href="#strictfp" class="headerlink" title="strictfp"></a>strictfp</h4><ul>
<li>使用它来声明一个类、接口或者方法时，那么所声明的范围内Java的编译器以及运行环境会完全依照浮点规范IEEE-754来执行。因此如果想让浮点运算更加精确，而且不会因为不同的硬件平台所执行的结果不一致的话，那就请用关键字strictfp。</li>
<li>可以将一个类、接口以及方法声明为strictfp，但是不允许对接口中的方法以及构造函数声明strictfp关键字。</li>
</ul>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><ul>
<li>可以应用于方法或语句块，并为一次只应由一个线程执行的关键代码段提供保护。 </li>
<li>可防止代码的关键代码段一次被多个线程执行。 </li>
<li>如果应用于静态方法，那么，当该方法一次由一个线程执行时，整个类将被锁定。 </li>
<li>如果应用于实例方法，那么，当该方法一次由一个线程访问时，该实例将被锁定。 </li>
<li>如果应用于对象或数组，当关联的代码块一次由一个线程执行时，对象或数组将被锁定。</li>
</ul>
<h3 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h3><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><ul>
<li>用于引用使用该关键字的类的超类。 </li>
<li>作为独立语句出现表示调用超类的构造方法。 </li>
</ul>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><ul>
<li>当引用可能不明确时，可以使用它来引用当前的实例。</li>
</ul>
<h4 id="void"><a href="#void" class="headerlink" title="void"></a>void</h4><ul>
<li>void 关键字表示 null 类型。 </li>
<li>void 可以用作方法的返回类型，以指示该方法不返回值。</li>
</ul>
<h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><h4 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h4><ul>
<li>保留关键字，但无任何作用。</li>
</ul>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><ul>
<li>类型修饰符，使用它声明的对象不能更新。</li>
</ul>
<h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java.IO"></a>Java.IO</h2><h3 id="java-io-File"><a href="#java-io-File" class="headerlink" title="java.io.File"></a>java.io.File</h3><p>File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入/输出流。</p>
<h4 id="public-File-String-pathname"><a href="#public-File-String-pathname" class="headerlink" title="public File(String pathname)"></a>public File(String pathname)</h4><p>以pathname为路径创建File对象，可以是绝对路径或者相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。</p>
<h4 id="public-File-String-parent-String-child"><a href="#public-File-String-parent-String-child" class="headerlink" title="public File(String parent,String child)"></a>public File(String parent,String child)</h4><p>以parent为父路径，child为子路径创建File对象。</p>
<h3 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h3><table>
<thead>
<tr>
<th>(抽象基类)</th>
<th><strong>字节流</strong></th>
<th><strong>字符流</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>输入流</strong></td>
<td><strong>InputStream</strong></td>
<td><strong>Reader</strong></td>
</tr>
<tr>
<td><strong>输出流</strong></td>
<td><strong>OutputStream</strong></td>
<td><strong>Writer</strong></td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">InputStream:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span>;</span><br><span class="line">Reader:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] c)</span></span>;</span><br><span class="line">---------------------</span><br><span class="line">OutputStream:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b/<span class="keyword">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b/<span class="keyword">char</span>[] cbuf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b/<span class="keyword">char</span>[] buff, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>; <span class="comment">//需要先刷新，再关闭此流</span></span><br><span class="line">Writer:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h3><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立一个流对象，将已存在的一个文件加载进流。</span></span><br><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"文件名.后缀"</span>);</span><br><span class="line"><span class="comment">//创建一个临时存放数据的数组。</span></span><br><span class="line"><span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//调用流对象的读取方法将流中的数据读入到数组中。</span></span><br><span class="line">fr.read(ch);</span><br></pre></td></tr></table></figure>
<h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建流对象，建立数据存放文件</span></span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"文件名.后缀"</span>);</span><br><span class="line"><span class="comment">//调用流对象的写入方法，将数据写入流</span></span><br><span class="line">fw.write(<span class="string">"要写入的数据"</span>);</span><br><span class="line"><span class="comment">//关闭流资源，并将流中的数据清空到文件中。</span></span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure>
<h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p><em>对于输出的缓冲流，写出的数据会先在内存中缓存，使用<strong>flush()</strong>将会使内存中的数据立刻写出。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">BufferedWriter bw = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//step1:创建缓冲流对象：它是过滤流，是对节点流的包装</span></span><br><span class="line">    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"d:\\IOTest\\source.txt"</span>));</span><br><span class="line">    bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"d:\\IOTest\\destBF.txt"</span>));</span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//一次读取字符文本文件的一行字符</span></span><br><span class="line">    <span class="keyword">while</span> ((str = br.readLine()) != <span class="keyword">null</span>) &#123; </span><br><span class="line">        bw.write(str); <span class="comment">//一次写入一行字符串</span></span><br><span class="line">        bw.newLine(); <span class="comment">//写入行分隔符</span></span><br><span class="line">    &#125;</span><br><span class="line">    bw.flush(); <span class="comment">//step2:刷新缓冲区</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// step3: 关闭IO流对象</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bw != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bw.close(); <span class="comment">//关闭过滤流时,会自动关闭它所包装的底层节点流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p><code>public InputSreamReader(InputStream in,String charsetName);</code></p>
<p>字节数组解码成字符串。</p>
<p><code>public OutputStreamWriter(OutputStream out,String charsetName);</code></p>
<p>字符串编码成字节数组。</p>
<h3 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h3><p>System.in的类型是InputStream。</p>
<p>System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"请输入信息(退出输入e或exit):"</span>);</span><br><span class="line"><span class="comment">//把"标准"输入流(键盘输入)这个字节流包装成字符流,再包装成缓冲流</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">    <span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span>) &#123; <span class="comment">//读取用户输入的一行数据 --&gt; 阻塞程序</span></span><br><span class="line">        <span class="keyword">if</span> (s.equalsIgnoreCase(<span class="string">"e"</span>) || s.equalsIgnoreCase(<span class="string">"exit"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"安全退出!!"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将读取到的整行字符串转成大写输出</span></span><br><span class="line">        System.out.println(<span class="string">"--&gt;:"</span>+s.toUpperCase());</span><br><span class="line">        System.out.println(<span class="string">"继续输入信息"</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123;</span><br><span class="line">            br.close(); <span class="comment">//关闭过滤流时,会自动关闭它包装的底层节点流</span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h3><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><ul>
<li><strong>对象序列化机制</strong>允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象</li>
<li>序列化的好处在于可将任<strong>何实现了Serializable接</strong>口的对象转化为<strong>字节数据</strong>，使其在保存和传输时可被还原</li>
<li>序列化是 RMI（Remote Method Invoke – 远程方法调用）过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此序列化机制是 JavaEE 平台的基础</li>
<li>如果需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一：<ul>
<li><strong>Serializable</strong></li>
<li>Externalizable</li>
</ul>
</li>
<li>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：<ul>
<li><strong>private static final long serialVersionUID;</strong></li>
<li>serialVersionUID用来表明类的不同版本间的兼容性</li>
<li>如果类没有显示定义这个静态变量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的源代码作了修改，serialVersionUID 可能发生变化。故建议，显示声明</li>
</ul>
</li>
<li>显示定义serialVersionUID的用途<ul>
<li>希望类的不同版本对序列化兼容，因此需确保类的不同版本具有相同的serialVersionUID</li>
<li>不希望类的不同版本对序列化兼容，因此需确保类的不同版本具有不同的serialVersionUID</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化对象韩梅梅。</span></span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"test3.txt"</span>));</span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">"韩梅梅"</span>,<span class="number">18</span>,<span class="string">"中华大街"</span>,<span class="keyword">new</span> Pet());</span><br><span class="line">oos.writeObject(p);</span><br><span class="line">oos.flush();</span><br><span class="line">oos.close();</span><br><span class="line"><span class="comment">//反序列化：将磁盘中的对象数据源读出。</span></span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test3.txt"</span>));</span><br><span class="line">Person p1 = (Person)ois.readObject();</span><br><span class="line">System.out.println(p1.toString());</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure>
<h2 id="Java-集合类"><a href="#Java-集合类" class="headerlink" title="Java 集合类"></a>Java 集合类</h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Collection</span><br><span class="line">|<span class="string">--	List</span></span><br><span class="line">|<span class="string">	</span>|<span class="string">--	ArrayList		//数组/线程不安全</span></span><br><span class="line">|<span class="string">	</span>|<span class="string">--	Vector			//数组/线程安全</span></span><br><span class="line">|<span class="string">	</span>|<span class="string">--	LinkedList		//链表</span></span><br><span class="line">|<span class="string">--	Set</span></span><br><span class="line">|<span class="string">	</span>|<span class="string">--	HashSet			//基于hashmap</span></span><br><span class="line">|<span class="string">	</span>|<span class="string">--	LinkedHashSet	//基于hashset</span></span><br><span class="line">|<span class="string">	</span>|<span class="string">--	TreeSet			//红黑树</span></span><br><span class="line"><span class="string">Map</span></span><br><span class="line">|<span class="string">--	---	HashMap			//链表+数组(JDK1.8 &gt;8红黑树)/线程不安全/拉链法/可null</span></span><br><span class="line">|<span class="string">--	---	HashTable		//线程安全(Synchronized)/键值都不可为null</span></span><br><span class="line">|<span class="string">--	---	LinkedHashMap	//基于hashmap</span></span><br><span class="line">|<span class="string">--	---	TreeMap			//红黑树</span></span><br><span class="line"></span><br><span class="line"><span class="string">ConcurrentHashMap		//线程安全/分段锁/JDK1.8 Node数组+链表+红黑树/synchronized CAS 。</span></span><br></pre></td></tr></table></figure>
<h2 id="Java-锁"><a href="#Java-锁" class="headerlink" title="Java 锁"></a>Java 锁</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><ul>
<li>在更新的时候会判断一下在此期间别人有没有去更新这个数据。</li>
<li>适用于多读的应用类型，这样可以提高吞吐量。</li>
<li>乐观锁的实现方式CAS、数据版本。</li>
<li>CAS(Compare and Swap 比较并交换)CAS操作中包含三个操作数——内存数据(V)、预期原值(A)、拟写入值(B)。如果V == A，那么更新V为新值B，否则不做任何操作。</li>
</ul>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><ul>
<li>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁。</li>
<li>在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。</li>
<li>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。</li>
</ul>
<h3 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁/非公平锁"></a>公平锁/非公平锁</h3><ul>
<li>公平锁是指多个线程按照申请锁的顺序来获取锁。</li>
<li>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。</li>
</ul>
<h3 id="偏向锁-轻量级锁-重量级锁"><a href="#偏向锁-轻量级锁-重量级锁" class="headerlink" title="偏向锁/轻量级锁/重量级锁"></a>偏向锁/轻量级锁/重量级锁</h3><ul>
<li>针对Synchronized。</li>
<li>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</li>
<li>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</li>
<li>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。</li>
</ul>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><ul>
<li>可重入锁。</li>
<li>非公平锁。</li>
<li>悲观锁 。</li>
<li>排他锁。</li>
</ul>
<h3 id="ReenTrantLock"><a href="#ReenTrantLock" class="headerlink" title="ReenTrantLock"></a>ReenTrantLock</h3><ul>
<li>可重入锁 。</li>
<li>可设置为公平锁。</li>
<li>排他锁。</li>
</ul>
</div><div class="tags"><a href="/tags/Java/">Java</a></div><div class="post-nav"><a class="pre" href="/post/blockchain/">区块链技术基础</a><a class="next" href="/post/markdownLead/">入门 Markdown</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://EricsmOOn.github.io/post/javaBase/';
    this.page.identifier = 'post/javaBase/';
    this.page.title = 'Java 基础';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//ericsmoon.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//ericsmoon.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://ericsmoon.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="https://EricsmOOn.github.io"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/摘录/">摘录</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机/">计算机</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/GC/" style="font-size: 15px;">GC</a> <a href="/tags/年终总结/" style="font-size: 15px;">年终总结</a> <a href="/tags/JMM/" style="font-size: 15px;">JMM</a> <a href="/tags/AQS/" style="font-size: 15px;">AQS</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/MarkDown/" style="font-size: 15px;">MarkDown</a> <a href="/tags/文档/" style="font-size: 15px;">文档</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/生活/" style="font-size: 15px;">生活</a> <a href="/tags/Java8/" style="font-size: 15px;">Java8</a> <a href="/tags/Lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/Stream/" style="font-size: 15px;">Stream</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/垃圾收集器/" style="font-size: 15px;">垃圾收集器</a> <a href="/tags/新枝/" style="font-size: 15px;">新枝</a> <a href="/tags/工作总结/" style="font-size: 15px;">工作总结</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/SSM/" style="font-size: 15px;">SSM</a> <a href="/tags/后台开发/" style="font-size: 15px;">后台开发</a> <a href="/tags/区块链/" style="font-size: 15px;">区块链</a> <a href="/tags/blockchain/" style="font-size: 15px;">blockchain</a> <a href="/tags/经济学/" style="font-size: 15px;">经济学</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/类加载机制/" style="font-size: 15px;">类加载机制</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/面经/" style="font-size: 15px;">面经</a> <a href="/tags/字节跳动/" style="font-size: 15px;">字节跳动</a> <a href="/tags/故事/" style="font-size: 15px;">故事</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/post/InterviewQuestionsJava/">Java后端开发面试题汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/post/java8new/">Java8 新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/post/ByteDanceInterview0118/">字节面经</a></li><li class="post-list-item"><a class="post-list-link" href="/post/DBMySQL/">MySQL 要点</a></li><li class="post-list-item"><a class="post-list-link" href="/post/Redis/">Redis 要点</a></li><li class="post-list-item"><a class="post-list-link" href="/post/JMM/">JMM(并发编程) 要点</a></li><li class="post-list-item"><a class="post-list-link" href="/post/x!nzhi/">新枝科技工作总结</a></li><li class="post-list-item"><a class="post-list-link" href="/post/JavaGC/">JVM 垃圾收集器</a></li><li class="post-list-item"><a class="post-list-link" href="/post/JVM/">JVM虚拟机</a></li><li class="post-list-item"><a class="post-list-link" href="/post/2019YearEndSummary/">2019年回溯&2020年方向</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Eric's Moon.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>