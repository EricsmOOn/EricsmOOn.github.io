<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Java后端开发面试题汇总 | Eric's Moon</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java后端开发面试题汇总</h1><a id="logo" href="/.">Eric's Moon</a><p class="description">为往圣继绝学 为万世开太平</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/friends/"><i class="fa fa-link"> 朋友</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java后端开发面试题汇总</h1><div class="post-meta">Mar 24, 2020<span> | </span><span class="category"><a href="/categories/计算机/">计算机</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 10.5k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 39</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" data-disqus-identifier="post/InterviewQuestionsJava/" href="/post/InterviewQuestionsJava/#disqus_thread"></a><div class="post-content"><h1 id="面试问题总结"><a href="#面试问题总结" class="headerlink" title="面试问题总结"></a>面试问题总结</h1><blockquote>
<p><strong>免责声明</strong></p>
<p><em>注意！本文档的回答仅供本人面试前回顾要点之用，不保证回答的完整性与正确性，若因本文档答案不正确而产生一切后果，请自行承担。</em></p>
</blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><span id="index">目录</span></h2><p><center><br><a href="#db"> 数据库</a><br><a href="#nw"> 计算机网络</a><br><a href="#c"> 高并发</a><br><a href="#smvc"> Spring MVC</a><br><a href="#s"> Spring</a><br><a href="#redis"> Redis</a><br><a href="#os"> Linux</a><br><a href="#collection"> Java集合类</a><br><a href="#fbs"> 分布式</a><br><a href="#design"> 设计模式</a><br><a href="#sort"> 排序算法</a><br><a href="#bd"> 海量数据</a><br><a href="#al"> 剑指Offer</a><br></center></p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><span id="db">数据库</span></h2><h4 id="数据库三大范式是什么？"><a href="#数据库三大范式是什么？" class="headerlink" title="数据库三大范式是什么？"></a>数据库三大范式是什么？</h4><details><br>    1NF 每一列属性不可再分<br>        2NF 消除非主属性对键的部分依赖 / <strong>非主属性完全依赖于主属性</strong><br>        3NF 消除非主属性对键的传递依赖<br></details>

<h4 id="MySQL有关权限的表都有哪几个？"><a href="#MySQL有关权限的表都有哪几个？" class="headerlink" title="MySQL有关权限的表都有哪几个？"></a>MySQL有关权限的表都有哪几个？</h4><details><br>        user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。<br>        db权限表：记录各个帐号在各个数据库上的操作权限。<br>        table_priv权限表：记录数据表级的操作权限。<br>        columns_priv权限表：记录数据列级的操作权限。<br>        host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。<br>​    </details>

<h4 id="MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="MySQL的binlog有有几种录入格式？分别有什么区别？"></a>MySQL的binlog有有几种录入格式？分别有什么区别？</h4><details><br>Statement：每一条会修改数据的SQL都会记录在binlog中。<br>Row：不记录sql语句，仅保存哪条记录被修改。<br>Mixed：一般的语句修改使用Statement，Statement无法完成主从复制的操作，则采用Row格式。 </details>

<h4 id="MySQL有哪些数据类型-？"><a href="#MySQL有哪些数据类型-？" class="headerlink" title="MySQL有哪些数据类型 ？"></a>MySQL有哪些数据类型 ？</h4><details><br>整形（BIGINT、INT、MEDIUINT、SMALLINT、TINYINT）、<br>浮点型（FLOAT、DOUBLE）、<br>日期时间（DATE、TIME、TIMESTAMP）、<br>字符串（CHAR、VARCHAR、LONGTEXT、MEDIUMTEXT、TEXT、TINYINT）。<br></details>

<h4 id="MySQL存储引擎MyISAM与InnoDB区别？"><a href="#MySQL存储引擎MyISAM与InnoDB区别？" class="headerlink" title="MySQL存储引擎MyISAM与InnoDB区别？"></a>MySQL存储引擎MyISAM与InnoDB区别？</h4><details>InnoDB支持事务、外键、使用聚集索引、最细粒度支持行级锁。<br>MyISAM不支持事务、外键、使用非聚集索引、最细粒度支持表锁。</details>

<h4 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h4><details> MyISAM索引文件和数据文件是分离的，索引文件仅保存记录所在页的指针（物理位置），通过这些地址来读取页，进而读取被索引的行。</details>


<h4 id="存储引擎选择-？"><a href="#存储引擎选择-？" class="headerlink" title="存储引擎选择 ？"></a>存储引擎选择 ？</h4><details>InnoDB需要维护MVCC以及聚簇索引所以比较慢。 </details>


<h4 id="索引有哪些优缺点？"><a href="#索引有哪些优缺点？" class="headerlink" title="索引有哪些优缺点？"></a>索引有哪些优缺点？</h4><details>加速查询、占用空间、修改时需要维护。 </details>

<h4 id="索引使用场景？"><a href="#索引使用场景？" class="headerlink" title="索引使用场景？"></a>索引使用场景？</h4><details>当数据多且字段值有相同的值得时候用普通索引。<br>当字段多且字段值没有重复的时候用唯一索引。<br>当有多个字段名都经常被查询的话用复合索引。 </details>

<h4 id="索引的数据结构-B-B-B-Hash-？"><a href="#索引的数据结构-B-B-B-Hash-？" class="headerlink" title="索引的数据结构(B/B- B+ Hash)？"></a>索引的数据结构(B/B- B+ Hash)？</h4><details><br>Hash无法范围查询、一直需要回表、大量Hash相等。<br>B树非叶子结点也存数据指针、无法范围查询。<br>B+树只有叶子结点存数据指针，且兄弟节点之间存在指针构成双向链表，范围查询。</details>

<h4 id="创建索引的原则？"><a href="#创建索引的原则？" class="headerlink" title="创建索引的原则？"></a>创建索引的原则？</h4><details> 对于查询频率高的字段创建索引。<br>索引的数目不宜太多。<br>尽量使用数据量少的索引。<br>尽量使用前缀来索引。</details>

<h4 id="什么是索引覆盖？"><a href="#什么是索引覆盖？" class="headerlink" title="什么是索引覆盖？"></a>什么是索引覆盖？</h4><details><br>select时where语句里的条件完全和联合索引一致覆盖索引，无需回表。<br></details> 

<h4 id="什么是最左前缀原则？"><a href="#什么是最左前缀原则？" class="headerlink" title="什么是最左前缀原则？"></a>什么是最左前缀原则？</h4><details> b+ 树的数据项是复合的数据结构，b+ 树是按照从左到右的顺序来建立搜索树的。</details>

<h4 id="如何查看SQL语句是否走了索引？"><a href="#如何查看SQL语句是否走了索引？" class="headerlink" title="如何查看SQL语句是否走了索引？"></a>如何查看SQL语句是否走了索引？</h4><p><br>explain + SQL语句，走了索引Extra会出现Using Index。<br></p>
<h4 id="平衡二叉树和红黑树的区别？"><a href="#平衡二叉树和红黑树的区别？" class="headerlink" title="平衡二叉树和红黑树的区别？"></a>平衡二叉树和红黑树的区别？</h4><details><br>AVL树是严格的平衡二叉树，必须满足所有节点的左右子树高度差不超过1，在修改时非常耗时，适合查找多的情况。<br>红黑树根节点是黑色的、红色节点下不能有红色节点、从根到任意一个节点经过的黑色节点数相同，维护起来比AVL树快捷。<br> </details>

<h4 id="B树和B-树的区别？"><a href="#B树和B-树的区别？" class="headerlink" title="B树和B+树的区别？"></a>B树和B+树的区别？</h4><details> B+树中只有叶子节点会带有指向记录的指针，而B树则所有节点都带有。<br>B+树中兄弟节点都是通过指针连接在一起，而B树不会。</details>

<h4 id="使用B树的好处？"><a href="#使用B树的好处？" class="headerlink" title="使用B树的好处？"></a>使用B树的好处？</h4><details>不需要到叶子结点即可得到数据。 </details>

<h4 id="使用B-树的好处？"><a href="#使用B-树的好处？" class="headerlink" title="使用B+树的好处？"></a>使用B+树的好处？</h4><details> 非叶子节点不会带上指向记录的指针，一个块中可以容纳更多的索引项。<br>可以进行范围查询。<br></details>

<h4 id="Hash索引和B-树所有有什么区别或者说优劣呢？"><a href="#Hash索引和B-树所有有什么区别或者说优劣呢？" class="headerlink" title="Hash索引和B+树所有有什么区别或者说优劣呢？"></a>Hash索引和B+树所有有什么区别或者说优劣呢？</h4><details>Hash不能范围查询、需要回表。 </details>

<h4 id="什么是聚簇索引？"><a href="#什么是聚簇索引？" class="headerlink" title="什么是聚簇索引？"></a>什么是聚簇索引？</h4><details> 聚簇索引是按照索引的顺序分配内存。</details>

<h4 id="非聚簇索引一定会回表查询吗？"><a href="#非聚簇索引一定会回表查询吗？" class="headerlink" title="非聚簇索引一定会回表查询吗？"></a>非聚簇索引一定会回表查询吗？</h4><details>不一定，如果查询是覆盖索引，也就是查询的字段全部命中了索引，那么就不需要回表查询。<br>若不是覆盖索引，需要回表检查其他属性值。</details>

<h4 id="为什么需要注意联合索引中的顺序？"><a href="#为什么需要注意联合索引中的顺序？" class="headerlink" title="为什么需要注意联合索引中的顺序？"></a>为什么需要注意联合索引中的顺序？</h4><details>满足最左匹配、命中索引。 </details>

<h4 id="什么是数据库事务？"><a href="#什么是数据库事务？" class="headerlink" title="什么是数据库事务？"></a>什么是数据库事务？</h4><details>满足ACID的一系列操作。 </details>

<h4 id="事物的四大特性-ACID-介绍一下"><a href="#事物的四大特性-ACID-介绍一下" class="headerlink" title="事物的四大特性(ACID)介绍一下?"></a>事物的四大特性(ACID)介绍一下?</h4><details>原子性：从结果上看事务要么全部成功要么全部失败。<br>一致性：事务前后不破坏数据的完整性约束。<br>隔离性：两个事务之间互不干扰，防止多个事务并发执行时由于交叉执行而导致数据的不一致。<br>持久性：事务一旦提交就会被持久化，即使故障也不应丢失。 </details>

<h4 id="什么是脏读？不可重复读？幻读？"><a href="#什么是脏读？不可重复读？幻读？" class="headerlink" title="什么是脏读？不可重复读？幻读？"></a>什么是脏读？不可重复读？幻读？</h4><details>脏读：事务A修改a未提交，事务B读取a，事务A回滚。<br>不可重复读：事务A读取a，事务B修改a，事务A再次读取a不一致。<br>幻读：事务A读取最后10行，事务B增加一行，事务A再次读取数据不一致。 </details>

<h4 id="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><a href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？" class="headerlink" title="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h4><details>读未提交、读已提交、可重复读、序列化。可重复读。 </details>

<h3 id="如何解决幻读？"><a href="#如何解决幻读？" class="headerlink" title="如何解决幻读？"></a>如何解决幻读？</h3><details>间隙锁，但是不能完全保证。使用序列化。 </details>

<h4 id="MVCC是什么？"><a href="#MVCC是什么？" class="headerlink" title="MVCC是什么？"></a>MVCC是什么？</h4><details> MVCC多版本并发控制，维护两个列：开始版本、删除版本。</details>

<h4 id="分布式事务存在的问题？解决方法有哪些？"><a href="#分布式事务存在的问题？解决方法有哪些？" class="headerlink" title="分布式事务存在的问题？解决方法有哪些？"></a>分布式事务存在的问题？解决方法有哪些？</h4><details> TCC，全局事务管理。</details>

<h4 id="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法？"><a href="#按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法？" class="headerlink" title="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法？"></a>按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法？</h4><details> InnoDB行锁是通过索引上的索引项来实现的。<br>只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁。</details>

<h4 id="InnoDB存储引擎的锁的算法有三种？"><a href="#InnoDB存储引擎的锁的算法有三种？" class="headerlink" title="InnoDB存储引擎的锁的算法有三种？"></a>InnoDB存储引擎的锁的算法有三种？</h4><details>行锁、next-key锁（查询防止幻读）、间隙锁（写入防止幻读）。 </details>

<h4 id="什么是死锁？怎么解决？"><a href="#什么是死锁？怎么解决？" class="headerlink" title="什么是死锁？怎么解决？"></a>什么是死锁？怎么解决？</h4><details>互斥、占有且等待、不可抢占、循环等待。 </details>

<h4 id="数据库的乐观锁和悲观锁是什么？怎么实现的？"><a href="#数据库的乐观锁和悲观锁是什么？怎么实现的？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？怎么实现的？"></a>数据库的乐观锁和悲观锁是什么？怎么实现的？</h4><details>乐观锁MVCC，悲观锁行锁、表锁。 </details>

<h4 id="什么是游标？"><a href="#什么是游标？" class="headerlink" title="什么是游标？"></a>什么是游标？</h4><details>可以把游标当作一个指针,它可以指定结果中的任何位置,然后允许用户对指定位置的数据进行处理。 </details>

<h4 id="MySQL的主从复制原理及流程？"><a href="#MySQL的主从复制原理及流程？" class="headerlink" title="MySQL的主从复制原理及流程？"></a>MySQL的主从复制原理及流程？</h4><details><br>前提，Master必须开启bin-log记录功能。<br>首先，Master开启IO线程，Slave开启IO线程和SQL线程。<br>Slave向Master请求bin-log某一位置后的日志内容，然后Master的IO线程传输到Slave线程的IO线程。<br>Slave的IO线程写到relay-log中。<br>Slave的SQL线程会监听relay-log是否有更新，然后解析并执行。<br> </details>

<h4 id="如何找到语句运行很慢的原因？"><a href="#如何找到语句运行很慢的原因？" class="headerlink" title="如何找到语句运行很慢的原因？"></a>如何找到语句运行很慢的原因？</h4><details>索引相关、未命中索引、不满足最左前缀匹配。<br>执行的时候，遇到锁，如表锁、行锁。<br><br> </details>

<p><a href="#index"><strong>回到目录</strong></a></p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a><span id="nw">计算机网络</span></h2><h4 id="OSI七层模型及每一层的协议？"><a href="#OSI七层模型及每一层的协议？" class="headerlink" title="OSI七层模型及每一层的协议？"></a>OSI七层模型及每一层的协议？</h4><details><br><br><img src="/images/OSI.jpg" alt><br></details><br><details><br>物理层        Ethernet<br>数据链路层    ARP<br>网络层        IP<br>传输层        TCP    UDP<br>会话层        RPC<br>表示层        HTML<br>应用层        FTP    Telnet SSH<br></details>

<h4 id="端口号在哪一层？"><a href="#端口号在哪一层？" class="headerlink" title="端口号在哪一层？"></a>端口号在哪一层？</h4><details><br>传输层。<br></details>

<h4 id="DNS查询的三种方式？"><a href="#DNS查询的三种方式？" class="headerlink" title="DNS查询的三种方式？"></a>DNS查询的三种方式？</h4><details><br>本地Host、根域名递归、迭代向上。<br></details>

<h4 id="为什么TCP连接的时候是3次？2次不可以吗？"><a href="#为什么TCP连接的时候是3次？2次不可以吗？" class="headerlink" title="为什么TCP连接的时候是3次？2次不可以吗？"></a>为什么TCP连接的时候是3次？2次不可以吗？</h4><h4 id="为什么TCP连接的时候是3次、关闭的时候却是4次？"><a href="#为什么TCP连接的时候是3次、关闭的时候却是4次？" class="headerlink" title="为什么TCP连接的时候是3次、关闭的时候却是4次？"></a>为什么TCP连接的时候是3次、关闭的时候却是4次？</h4><details><br>握手时把2、3次合并了。<br></details>

<h4 id="TCP与UDP的区别？"><a href="#TCP与UDP的区别？" class="headerlink" title="TCP与UDP的区别？"></a>TCP与UDP的区别？</h4><details><br>面向连接、有序、可靠性。<br></details>

<h4 id="TCP如何保证可靠性传输？"><a href="#TCP如何保证可靠性传输？" class="headerlink" title="TCP如何保证可靠性传输？"></a>TCP如何保证可靠性传输？</h4><details><br>确认应答、超时重答、拥塞控制、流量控制。<br></details>

<h4 id="什么是超时重答机制？"><a href="#什么是超时重答机制？" class="headerlink" title="什么是超时重答机制？"></a>什么是超时重答机制？</h4><details><br>TCP每发送一个报文段，就会对这个报文段设置一次计时器，只要计时器设置的 重传时间到，但发送端还没有收到接收端发来的确认，此时就会重传此报文段。<br></details>

<h4 id="说说TCP的流量控制？"><a href="#说说TCP的流量控制？" class="headerlink" title="说说TCP的流量控制？"></a>说说TCP的流量控制？</h4><details><br>接收端将自己可以接受的缓冲区大小放入TCP首部中的“窗口大小”字段，通过ACK段通知发送端；<br>窗口大小字段越大，说明网络的吞吐量越高<br>接收端一旦发现自己的缓冲区快满了就会将窗口大小设置成一个更小的值通知发送端。<br>发送端接收到窗口大小以后，就会减慢自己的发送速度。<br>如果接收缓冲区满了，就会将窗口置为0，这时发送方不再发送数据。<br></details>

<h4 id="说说TCP的拥塞控制算法？"><a href="#说说TCP的拥塞控制算法？" class="headerlink" title="说说TCP的拥塞控制算法？"></a>说说TCP的拥塞控制算法？</h4><details><br>慢启动算法 每次乘以2<br>拥塞避免算法 超过慢启动门限则每次加1<br></details>

<h4 id="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"><a href="#为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？" class="headerlink" title="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"></a>为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</h4><details><br>主动挥手方Time-Wait，确保对面收到了ACK，否则对面会再次发送FIN。<br></details>

<h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><details><br>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。<br></details>

<h4 id="路由器和交换机的区别？"><a href="#路由器和交换机的区别？" class="headerlink" title="路由器和交换机的区别？"></a>路由器和交换机的区别？</h4><details><br><br>交换机主要工作在数据链路层、路由器工作在网络层。<br><br>交换机根据MAC地址转发、路由器根据IP地址转发。<br><br>路由谋短，交换求快。<br><br></details>

<h4 id="HTTP的幂等性是什么？"><a href="#HTTP的幂等性是什么？" class="headerlink" title="HTTP的幂等性是什么？"></a>HTTP的幂等性是什么？</h4><details><br><br><strong>任意多次执行对资源本身所产生的影响均与一次执行的影响相同</strong>。<br><br>幂等使用的情况是第一次请求不知道结果（比如超时）或者失败的异常情况下，发起多次请求，目的是多次确认第一次请求成功，却不会因多次请求而出现多次的状态变化。<br><br>这种方式分成两个阶段：申请token阶段和支付阶段。 第一阶段，在进入到提交订单页面之前，需要订单系统根据用户信息向支付系统发起一次申请token的请求，支付系统将token保存到Redis缓存中，为第二阶段支付使用。 第二阶段，订单系统拿着申请到的token发起支付请求，支付系统会检查Redis中是否存在该token，如果存在，表示第一次发起支付请求，删除缓存中token后开始支付逻辑处理；如果缓存中不存在，表示非法请求。 实际上这里的token是一个信物，支付系统根据token确认，<br><br></details>

<h4 id="HTTP-建立连接的过程？"><a href="#HTTP-建立连接的过程？" class="headerlink" title="HTTP 建立连接的过程？"></a>HTTP 建立连接的过程？</h4><details><br>DNS、TCP、客户端请求、Web响应、Connection：keep-alive 控制是否立即关闭、客户端解析资源渲染页面。<br></details>

<h4 id="HTTP-的长链接？"><a href="#HTTP-的长链接？" class="headerlink" title="HTTP 的长链接？"></a>HTTP 的长链接？</h4><details><br><br>短链接指客户端每进行一次HTTP请求就建立一次连接，任务结束连接就中断，比如访问一个网页或者其他web资源，每遇到一个web资源就要建立一次连接。<br><br>HTTP1.1之后默认使用长链接，就是说TCP连接在完成任务后继续保持连接不进行四次挥手，保活机制，2小时，75秒，10次。<br></details>

<h4 id="HTTPS-建立连接的过程？"><a href="#HTTPS-建立连接的过程？" class="headerlink" title="HTTPS 建立连接的过程？"></a>HTTPS 建立连接的过程？</h4><details><br>DNS、TCP、客户端请求、Web响应SSL证书以及公钥、客户端验证SSL、客户端生成对称加密用公钥加密给Web、Web私钥解密、用对称加密传输、Connection：keep-alive 控制是否立即关闭、客户端解析资源渲染页面。<br></details>

<h4 id="常用HTTP状态码？"><a href="#常用HTTP状态码？" class="headerlink" title="常用HTTP状态码？"></a>常用HTTP状态码？</h4><details><br>100 继续发送请求<br>200 成功<br>301 永久移动<br>302 临时移动<br>307 临时重定向<br>404 NotFound<br>500 服务器内部错误<br>502 BadGateWay<br>503 服务不可用<br></details>

<h4 id="HTTP头包括什么？"><a href="#HTTP头包括什么？" class="headerlink" title="HTTP头包括什么？"></a>HTTP头包括什么？</h4><details><br><em>请求头</em><br>GET /newcoder/hello.html  HTTP/1.1<br>Accept:<br>Accept-Language: en-us<br>Connection: Keep-Alive<br>Host:<br>Referer:<br>User-Agent: Mozilla/4.0<br>Accept-Encoding: gzip, deflate<br>Cookie<br>Date: Tue, 11 Jul 2000 00:00:00 GMT<br><br><em>响应头</em><br>Content-Encoding: gzip<br>Content-Length: 80<br>Content-Language: zh-cn<br>Content-Type: text/html; charset=GB2312<br></details>

<h4 id="GET和POST区别？"><a href="#GET和POST区别？" class="headerlink" title="GET和POST区别？"></a>GET和POST区别？</h4><details><br>GET产生一个TCP数据包，POST产生两个TCP数据包。<br>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。<br></details>

<h4 id="什么是HTTP2-0？"><a href="#什么是HTTP2-0？" class="headerlink" title="什么是HTTP2.0？"></a>什么是HTTP2.0？</h4><details><br><strong>HTTP 2.0 的所有帧都采用二进制编码</strong><br>HTTP 2.0多个请求可同时在一个连接上并行执行。通过分帧，某个请求任务耗时严重，不会影响到其它连接的正常执行。<br></details>

<h4 id="Session、Cookie和Token的主要区别？"><a href="#Session、Cookie和Token的主要区别？" class="headerlink" title="Session、Cookie和Token的主要区别？"></a>Session、Cookie和Token的主要区别？</h4><details><br>服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。<br>cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。<br></details>

<h4 id="Servlet是线程安全的吗？"><a href="#Servlet是线程安全的吗？" class="headerlink" title="Servlet是线程安全的吗？"></a>Servlet是线程安全的吗？</h4><details><br>Servlet不是线程安全的。<br>因为Servlet是单例模式的。<br></details>

<h4 id="Servlet生命周期？"><a href="#Servlet生命周期？" class="headerlink" title="Servlet生命周期？"></a>Servlet生命周期？</h4><details><br>Servlet 通过调用 <strong>init ()</strong> 方法进行初始化。<br>Servlet 调用 <strong>service()</strong> 方法来处理客户端的请求。<br>Servlet 通过调用 <strong>destroy()</strong> 方法终止（结束）。<br>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。<br></details>

<h4 id="网络IO模型有哪些"><a href="#网络IO模型有哪些" class="headerlink" title="网络IO模型有哪些?"></a>网络IO模型有哪些?</h4><details><br>阻塞IO、非阻塞IO、多路复用IO、信号驱动IO、异步IO。<br></details>

<h4 id="I-O多路复用中select-poll-epoll的区别？"><a href="#I-O多路复用中select-poll-epoll的区别？" class="headerlink" title="I/O多路复用中select/poll/epoll的区别？"></a>I/O多路复用中select/poll/epoll的区别？</h4><h4 id="select的三个缺点？"><a href="#select的三个缺点？" class="headerlink" title="select的三个缺点？"></a>select的三个缺点？</h4><details><br>大量文件句柄拷贝从用户态到内核态。<br>轮询大量文件句柄。<br>限制1024个。<br></details>

<h4 id="epoll怎么克服这三个缺点的？"><a href="#epoll怎么克服这三个缺点的？" class="headerlink" title="epoll怎么克服这三个缺点的？"></a>epoll怎么克服这三个缺点的？</h4><details><br>epoll结构体、红黑树注册文件句柄、双向链表保存响应的文件句柄、callback注册进双向链表。<br>水平触发只要有内容则触发。<br>边缘触发只提醒一次。<br></details>

<p><a href="#index"><strong>回到目录</strong></a></p>
<h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a><span id="gbf">高并发</span></h2><h4 id="并发编程三要素是什么？"><a href="#并发编程三要素是什么？" class="headerlink" title="并发编程三要素是什么？"></a>并发编程三要素是什么？</h4><details><br><br>原子性：是一个或多个操作要么全部执行成功要么全部执行失败。<br><br>有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）<br><br>可见性：一个线程对共享变量的修改,另一个线程能够立刻看到。<br><br></details>

<h4 id="在-Java-程序中怎么保证多线程的运行安全？"><a href="#在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="在 Java 程序中怎么保证多线程的运行安全？"></a>在 Java 程序中怎么保证多线程的运行安全？</h4><details><br><br>JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题。<br><br>synchronized、volatile、LOCK，可以解决可见性问题。<br><br>Happens-Before 规则可以解决有序性问题。<br><br></details>

<h4 id="创建线程有哪几种方式？"><a href="#创建线程有哪几种方式？" class="headerlink" title="创建线程有哪几种方式？"></a>创建线程有哪几种方式？</h4><details><br><br>继承Thread、实现runnable、实现callable、线程池。<br><br></details>

<h4 id="说一下-runnable-和-callable-有什么区别？"><a href="#说一下-runnable-和-callable-有什么区别？" class="headerlink" title="说一下 runnable 和 callable 有什么区别？"></a>说一下 runnable 和 callable 有什么区别？</h4><details><br><br>callable可以返回执行结果、一般与FutureTask共同使用。<br><br></details>

<h4 id="说说线程的生命周期及五种基本状态？"><a href="#说说线程的生命周期及五种基本状态？" class="headerlink" title="说说线程的生命周期及五种基本状态？"></a>说说线程的生命周期及五种基本状态？</h4><details><br><br>新建态、就绪态、运行态、阻塞态、终止态。<br><br></details>

<h4 id="Java-中用到的线程调度算法是什么？"><a href="#Java-中用到的线程调度算法是什么？" class="headerlink" title="Java 中用到的线程调度算法是什么？"></a>Java 中用到的线程调度算法是什么？</h4><details><br><br>抢占式线程调度（Preemptive Threads-Scheduling）。<br><br></details>

<h4 id="Java-中用到的线程模型是什么？"><a href="#Java-中用到的线程模型是什么？" class="headerlink" title="Java 中用到的线程模型是什么？"></a>Java 中用到的线程模型是什么？</h4><details><br><br>使用一对一的线程模型实现的，一条Java线程就映射到一条轻量级进程之中，交由操作系统调度。<br><br></details>

<h4 id="sleep-和-wait-有什么区别？"><a href="#sleep-和-wait-有什么区别？" class="headerlink" title="sleep() 和 wait() 有什么区别？"></a>sleep() 和 wait() 有什么区别？</h4><details><br><br>sleep的类是Thread，会自动唤醒，释放锁。<br><br>wait的类是Object，必须被唤醒，不释放锁。<br><br></details>

<h4 id="你是如何调用-wait-方法的？使用-if-块还是循环？为什么？"><a href="#你是如何调用-wait-方法的？使用-if-块还是循环？为什么？" class="headerlink" title="你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？"></a>你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？</h4><details><br><br>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。<br><br></details>

<h4 id="为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？"><a href="#为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？" class="headerlink" title="为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？"></a>为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</h4><details><br><br>任何对象都可以作为锁，而所有类都继承于Object。<br><br></details>

<h4 id="为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？"><a href="#为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？"></a>为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</h4><details><br><br>调用wait()就是释放锁，释放锁的前提是必须要先获得锁，先获得锁才能释放锁。<br><br></details>

<h4 id="Thread-类中的-yield-方法有什么作用？"><a href="#Thread-类中的-yield-方法有什么作用？" class="headerlink" title="Thread 类中的 yield 方法有什么作用？"></a>Thread 类中的 yield 方法有什么作用？</h4><details><br><br>它让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。它可能会获取到，也有可能被其他线程获取到。<br><br></details>

<h4 id="为什么-Thread-类的-sleep-和-yield-方法是静态的？"><a href="#为什么-Thread-类的-sleep-和-yield-方法是静态的？" class="headerlink" title="为什么 Thread 类的 sleep()和 yield ()方法是静态的？"></a>为什么 Thread 类的 sleep()和 yield ()方法是静态的？</h4><details><br><br>Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。<br><br></details>

<h4 id="线程的-sleep-方法和-yield-方法有什么区别？"><a href="#线程的-sleep-方法和-yield-方法有什么区别？" class="headerlink" title="线程的 sleep()方法和 yield()方法有什么区别？"></a>线程的 sleep()方法和 yield()方法有什么区别？</h4><details><br><br>sleep()方法给其他线程运行机会时不考虑线程的优先级,因此会给低优先级的线程以运行的机会。<br><br>yield()方法只会给相同优先级或更高优先级的线程以运行的机会。<br><br></details>

<h4 id="如何在两个线程间共享数据？"><a href="#如何在两个线程间共享数据？" class="headerlink" title="如何在两个线程间共享数据？"></a>如何在两个线程间共享数据？</h4><details><br><br>同一个Runnable用内部变量。<br><br>不同封装一个类。<br><br></details>

<h4 id="Java-如何实现多线程之间的通讯和协作？"><a href="#Java-如何实现多线程之间的通讯和协作？" class="headerlink" title="Java 如何实现多线程之间的通讯和协作？"></a>Java 如何实现多线程之间的通讯和协作？</h4><details><br><br>锁。<br><br></details>

<h4 id="synchronized-的作用？"><a href="#synchronized-的作用？" class="headerlink" title="synchronized 的作用？"></a>synchronized 的作用？</h4><details><br><br>能够保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果。<br><br></details>

<h4 id="说一下-synchronized-底层实现原理？"><a href="#说一下-synchronized-底层实现原理？" class="headerlink" title="说一下 synchronized 底层实现原理？"></a>说一下 synchronized 底层实现原理？</h4><details><br><br>同步代码块是通过 monitorenter 和 monitorexit 指令获取线程的执行权<br><br>同步方法通过加 ACC_SYNCHRONIZED 标识实现线程的执行权的控制<br><br></details>

<h4 id="多线程中-synchronized-锁升级的原理是什么？"><a href="#多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="多线程中 synchronized 锁升级的原理是什么？"></a>多线程中 synchronized 锁升级的原理是什么？</h4><h4 id="当一个线程进入一个对象的-synchronized-方法-A-之后，其它线程是否可进入此对象的-synchronized-方法-B？"><a href="#当一个线程进入一个对象的-synchronized-方法-A-之后，其它线程是否可进入此对象的-synchronized-方法-B？" class="headerlink" title="当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？"></a>当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？</h4><details><br><br>不能，要进行同步方法必须持有他的对象锁。<br><br></details>

<h4 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h4><details><br><br>源码级别、API方法。<br><br>Lock可知道是否获取锁。<br><br>synchronized不需要手动释放锁。<br><br></details>

<h4 id="volatile-关键字的作用？"><a href="#volatile-关键字的作用？" class="headerlink" title="volatile 关键字的作用？"></a>volatile 关键字的作用？</h4><details><br><br>指明该变量不稳定，保证可见性。<br><br></details>

<h4 id="Java-中能创建-volatile-数组吗？"><a href="#Java-中能创建-volatile-数组吗？" class="headerlink" title="Java 中能创建 volatile 数组吗？"></a>Java 中能创建 volatile 数组吗？</h4><details><br><br>能，java中可以创建volatile数组，不过只是一个指向数组的引用，而不是整个数组，如果改变引用指向的数组，将会受到volatile的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。<br><br></details>

<h4 id="volatile-变量和-atomic-变量有什么不同？"><a href="#volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="volatile 变量和 atomic 变量有什么不同？"></a>volatile 变量和 atomic 变量有什么不同？</h4><details><br><br>volatile保证可见性，atomic保证可见性和原子性。<br><br></details>

<h4 id="synchronized-和-volatile-的区别是什么？"><a href="#synchronized-和-volatile-的区别是什么？" class="headerlink" title="synchronized 和 volatile 的区别是什么？"></a>synchronized 和 volatile 的区别是什么？</h4><h4 id="什么是-CAS？"><a href="#什么是-CAS？" class="headerlink" title="什么是 CAS？"></a>什么是 CAS？</h4><h4 id="CAS-的会产生什么问题？如何解决？"><a href="#CAS-的会产生什么问题？如何解决？" class="headerlink" title="CAS 的会产生什么问题？如何解决？"></a>CAS 的会产生什么问题？如何解决？</h4><details><br><br>ABA问题，引入版本。<br><br></details>

<h4 id="ThreadLocal-是什么？有哪些使用场景？"><a href="#ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="ThreadLocal 是什么？有哪些使用场景？"></a>ThreadLocal 是什么？有哪些使用场景？</h4><details><br><br>线程本地变量，经典的使用场景是为每个线程分配一个 JDBC 连接 Connection。这样就可以保证每个线程的都在各自的 Connection 上进行数据库的操作，不会出现 A 线程关了 B线程正在使用的 Connection、还有 Session 管理 等问题。<br><br></details>

<h4 id="ThreadLocal造成内存泄漏的原因？"><a href="#ThreadLocal造成内存泄漏的原因？" class="headerlink" title="ThreadLocal造成内存泄漏的原因？"></a>ThreadLocal造成内存泄漏的原因？</h4><h4 id="线程池有哪几种创建方式？"><a href="#线程池有哪几种创建方式？" class="headerlink" title="线程池有哪几种创建方式？"></a>线程池有哪几种创建方式？</h4><details><br><br><code>newCachedThreadPool()</code>，它是用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置时间超过60秒，则被终止并移除缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使<code>SynchronousQueue</code>作为工作队列。<br><br><code>newFixedThreadPool(int nThreads)</code>，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动线程数目，将在工作队列中等待空闲线程出现；如果工作线程退出，将会有新的工作线程被创建，以补足指定数目nThreads。<br><br><code>newSingleThreadExecutor()</code>，它的特点在于工作线程数目限制为1，操作一个无界的工作队列，所以它保证了所有的任务都是被顺序执行，最多会有一个任务处于活动状态，并且不予许使用者改动线程池实例，因此可以避免改变线程数目。<br><br><code>newScheduledThreadPool(int corePoolSize)</code>，创建的是个ScheduledExecutorService，可以进行定时或周期性的工作调度。<br><br></details>

<h4 id="线程池参数？"><a href="#线程池参数？" class="headerlink" title="线程池参数？"></a>线程池参数？</h4><details><br><br>corePoolSize：核心线程数，核心线程会一直存活，即使没有任务需要执行。<br><br>maxPoolSize：最大线程数。<br><br>keepAliveTime：线程空闲时间。<br><br></details>

<h4 id="可重入锁如何实现可重入的？"><a href="#可重入锁如何实现可重入的？" class="headerlink" title="可重入锁如何实现可重入的？"></a>可重入锁如何实现可重入的？</h4><details><br><br>volatile int state 计数。<br><br>Synchronized 使用对象监视器。会在对象头部有个区域，专门记录锁信息。包括持有锁的线程，锁的计数器，锁的状态这些。 线程在尝试获取对象锁时，先看看锁计数器是不是为0，为零就说明锁还在，于是获取锁，计数器变成1，并记录下持有锁的线程，当有线程再来请求同步方法时，先看看是不是当前持有锁的线程，是的，那就直接访问，锁计数器+1，如果不是，对不起，你阻塞吧。当退出同步块时，计数器-1，变成0时，释放锁。<br><br></details>

<h4 id="什么是MarkWord？"><a href="#什么是MarkWord？" class="headerlink" title="什么是MarkWord？"></a>什么是MarkWord？</h4><details><br><br>存在于对象头中用于指示锁的状态、hashCode、GC年龄等信息。<br><br></details>

<h4 id="在-JUC-中有哪些原子类？"><a href="#在-JUC-中有哪些原子类？" class="headerlink" title="在 JUC 中有哪些原子类？"></a>在 JUC 中有哪些原子类？</h4><details><br><br>AtomicInteger、AtomicLong、AtomicBoolean。<br><br></details>

<h4 id="说一下原子类的原理？"><a href="#说一下原子类的原理？" class="headerlink" title="说一下原子类的原理？"></a>说一下原子类的原理？</h4><details><br><br>volatile修饰、CAS操作。<br><br></details>

<p><a href="#index"><strong>回到目录</strong></a></p>
<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a><span id="smvc">Spring MVC</span></h2><h4 id="请求处理的整个过程？"><a href="#请求处理的整个过程？" class="headerlink" title="请求处理的整个过程？"></a>请求处理的整个过程？</h4><details><br><br><code>DispatcherServlet</code>前端控制器接收发过来的请求，把URL交给<code>HandlerMapping</code>处理器映射器。<br><br><code>HandlerMapping</code>处理器映射器，根据调用链找到相应的<code>HandlerAdapter</code>处理器适配器。<br><br><code>HandlerAdapter</code>处理器适配器，调用<code>Controller</code>，返回一个<code>ModelAndView</code>对象。<br><br><code>ViewResolver</code>视图解析器，先根据<code>ModelAndView</code>中设置的View解析具体视图，然后再将Model模<br><br>型中的数据渲染到View上，返回给前端。<br><br></details>

<p><a href="#index"><strong>回到目录</strong></a></p>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a><span id="s">Spring</span></h2><h4 id="Spring-IoC-的实现机制？"><a href="#Spring-IoC-的实现机制？" class="headerlink" title="Spring IoC 的实现机制？"></a>Spring IoC 的实现机制？</h4><details><br><br>通过反射机制实例化Bean，若为单例模式则在容器创建时实例化Bean，若为多例模式则在使用时实例化Bean。<br><br></details>

<h4 id="BeanFactory-和-ApplicationContext有什么区别？"><a href="#BeanFactory-和-ApplicationContext有什么区别？" class="headerlink" title="BeanFactory 和 ApplicationContext有什么区别？"></a>BeanFactory 和 ApplicationContext有什么区别？</h4><details><br><br>BeanFactory用来懒加载创建多例模式的多个Bean实例。<br><br>ApplicationContext是BeanFactory的子接口用于创建单例模式Bean实例。<br><br></details>

<h4 id="构造器依赖注入和-Setter方法注入的区别？"><a href="#构造器依赖注入和-Setter方法注入的区别？" class="headerlink" title="构造器依赖注入和 Setter方法注入的区别？"></a>构造器依赖注入和 Setter方法注入的区别？</h4><details><br><br>构造器注入采用有参构造函数进行属性设置，Setter方法注入采用Setter进行属性设置。<br><br></details>

<h4 id="bean的作用域？"><a href="#bean的作用域？" class="headerlink" title="bean的作用域？"></a>bean的作用域？</h4><details><br><br>singleton、prototype、request、session、globalSession。<br><br></details>

<h4 id="Spring框架中的单例bean是线程安全的吗？"><a href="#Spring框架中的单例bean是线程安全的吗？" class="headerlink" title="Spring框架中的单例bean是线程安全的吗？"></a>Spring框架中的单例bean是线程安全的吗？</h4><details><br><br>不是，要保证线程安全要使用prototype。<br><br></details>

<h4 id="bean的生命周期？"><a href="#bean的生命周期？" class="headerlink" title="bean的生命周期？"></a>bean的生命周期？</h4><h4 id="初始化Bean的过程？"><a href="#初始化Bean的过程？" class="headerlink" title="初始化Bean的过程？"></a>初始化Bean的过程？</h4><details><br><br><br><br></details>

<h4 id="解决Bean间循环依赖？"><a href="#解决Bean间循环依赖？" class="headerlink" title="解决Bean间循环依赖？"></a>解决Bean间循环依赖？</h4><details><br><br><br><br></details>

<h4 id="什么是AOP？如何实现？"><a href="#什么是AOP？如何实现？" class="headerlink" title="什么是AOP？如何实现？"></a>什么是AOP？如何实现？</h4><details><br><br>面向切面编程，通过动态代理实现。<br><br></details>

<h4 id="JDK动态代理和CGLIB动态代理的区别？"><a href="#JDK动态代理和CGLIB动态代理的区别？" class="headerlink" title="JDK动态代理和CGLIB动态代理的区别？"></a>JDK动态代理和CGLIB动态代理的区别？</h4><details><br><br>JDK动态代理是通过接口代理的，需要被代理类有实现接口。利用拦截器加上反射机制生成一个实现代理接口的匿名类， 在调用具体方法前调用InvokeHandler来处理。<br><br>CGLIB动态代理通过子类进行代理，对指定的类生成一个子类，修改其字节码，覆盖其中的方法。<br><br></details>

<p><a href="#toc"><strong>回到目录</strong></a></p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><span id="redis">Redis</span></h2><h4 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h4><h4 id="Redis有哪些数据类型？底层实现？"><a href="#Redis有哪些数据类型？底层实现？" class="headerlink" title="Redis有哪些数据类型？底层实现？"></a>Redis有哪些数据类型？底层实现？</h4><h4 id="Redis的应用场景？"><a href="#Redis的应用场景？" class="headerlink" title="Redis的应用场景？"></a>Redis的应用场景？</h4><h4 id="Redis-的持久化机制是什么？各自的优缺点？"><a href="#Redis-的持久化机制是什么？各自的优缺点？" class="headerlink" title="Redis 的持久化机制是什么？各自的优缺点？"></a>Redis 的持久化机制是什么？各自的优缺点？</h4><h4 id="过期键的删除策略？"><a href="#过期键的删除策略？" class="headerlink" title="过期键的删除策略？"></a>过期键的删除策略？</h4><h4 id="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？"><a href="#MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？" class="headerlink" title="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？"></a>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？</h4><h4 id="Redis的内存淘汰策略有哪些？"><a href="#Redis的内存淘汰策略有哪些？" class="headerlink" title="Redis的内存淘汰策略有哪些？"></a>Redis的内存淘汰策略有哪些？</h4><h4 id="Redis线程模型？"><a href="#Redis线程模型？" class="headerlink" title="Redis线程模型？"></a>Redis线程模型？</h4><details><br><br>展示了文件事件处理器的四个组成部分， 它们分别是套接字、 I/O 多路复用程序、 文件事件分派器（dispatcher）、 以及事件处理器。<br><br></details>

<h4 id="Redis事务的三个阶段？"><a href="#Redis事务的三个阶段？" class="headerlink" title="Redis事务的三个阶段？"></a>Redis事务的三个阶段？</h4><details><br><br>MULTI、DISCARD、EXEC。<br><br>语法错误全部失效、运行时错误单个报错其他执行。<br><br></details>

<h4 id="哨兵模式？"><a href="#哨兵模式？" class="headerlink" title="哨兵模式？"></a>哨兵模式？</h4><h4 id="Redis集群的主从复制模型是怎样的？"><a href="#Redis集群的主从复制模型是怎样的？" class="headerlink" title="Redis集群的主从复制模型是怎样的？"></a>Redis集群的主从复制模型是怎样的？</h4><details><br><br>基于分布式一致性算法RAFT，但是Master宕机选举使用哨兵集群。<br><br></details>

<h4 id="说说Redis哈希槽的概念？"><a href="#说说Redis哈希槽的概念？" class="headerlink" title="说说Redis哈希槽的概念？"></a>说说Redis哈希槽的概念？</h4><details><br><br>Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。<br><br></details>

<h4 id="Redis集群会有写操作丢失吗？为什么？"><a href="#Redis集群会有写操作丢失吗？为什么？" class="headerlink" title="Redis集群会有写操作丢失吗？为什么？"></a>Redis集群会有写操作丢失吗？为什么？</h4><details><br><br>有，若Master在接受写操作后未进行主从复制即宕机，则丢失数据。<br><br></details>

<h4 id="Redis集群之间是如何复制的？"><a href="#Redis集群之间是如何复制的？" class="headerlink" title="Redis集群之间是如何复制的？"></a>Redis集群之间是如何复制的？</h4><details><br><br>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。<br><br></details>

<h4 id="Redis集群最大节点个数是多少？"><a href="#Redis集群最大节点个数是多少？" class="headerlink" title="Redis集群最大节点个数是多少？"></a>Redis集群最大节点个数是多少？</h4><details><br><br>在redis节点发送心跳包时需要把所有的槽放到这个心跳包里，以便让节点知道当前集群信息，16384=16k，在发送心跳包时使用<code>char</code>进行bitmap压缩后是2k（<code>2 * 8 (8 bit) * 1024(1k) = 2K</code>），也就是说使用2k的空间创建了16k的槽数。<br><br>虽然使用CRC16算法最多可以分配65535（2^16-1）个槽位，65535=65k，压缩后就是8k（<code>8 * 8 (8 bit) * 1024(1k) = 8K</code>），也就是说需要需要8k的心跳包，作者认为这样做不太值得；并且一般情况下一个redis集群不会有超过1000个master节点，所以16k的槽位是个比较合适的选择。<br><br></details>

<h4 id="Redis实现分布式锁？"><a href="#Redis实现分布式锁？" class="headerlink" title="Redis实现分布式锁？"></a>Redis实现分布式锁？</h4><h4 id="如何解决-Redis-的并发竞争-Key-问题"><a href="#如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="如何解决 Redis 的并发竞争 Key 问题?"></a>如何解决 Redis 的并发竞争 Key 问题?</h4><details><br><br>消息队列、分布式锁+时间戳（时间戳是为了防止要求有序性）。<br><br></details>

<h4 id="缓存雪崩、缓存穿透、缓存击穿、缓存预热、缓存降级？"><a href="#缓存雪崩、缓存穿透、缓存击穿、缓存预热、缓存降级？" class="headerlink" title="缓存雪崩、缓存穿透、缓存击穿、缓存预热、缓存降级？"></a>缓存雪崩、缓存穿透、缓存击穿、缓存预热、缓存降级？</h4><h4 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h4><h4 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h4><details><br><br>使用keys指令可以扫出指定模式的key列表。<br><br>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？<br><br>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。<br><br></details>

<h4 id="Redis回收使用的是什么算法？"><a href="#Redis回收使用的是什么算法？" class="headerlink" title="Redis回收使用的是什么算法？"></a>Redis回收使用的是什么算法？</h4><details><br><br>引用计数器和LRU。<br><br></details>

<p><a href="#index"><strong>回到目录</strong></a></p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a><span id="os">Linux</span></h2><h4 id="进程间通信方式？哪种最快？"><a href="#进程间通信方式？哪种最快？" class="headerlink" title="进程间通信方式？哪种最快？"></a>进程间通信方式？哪种最快？</h4><details><br><br>管道，命名管道和非命名管道。非命名管道只能用于父子进程通讯，命名管道可用于非父子进程，命名管道就是FIFO，只允许数据的单向流动。每个FIFO都有一个名字，允许不相关的进程访问同一个FIFO。<br><br>消息队列：是用于两个进程之间的通讯，首先在一个进程中创建一个消息队列，然后再往消息队列中写数据，而另一个进程则从那个消息队列中取数据。<br><br>信号量， 不能传递复杂消息，只能用来同步。<br><br>共享内存最快，只要首先创建一个共享内存区，其它进程按照一定的步骤就能访问到这个共享内存区中的数据，当然可读可写。<br><br></details>

<h4 id="线程间通信方式？"><a href="#线程间通信方式？" class="headerlink" title="线程间通信方式？"></a>线程间通信方式？</h4><details><br><br>锁、信号量。<br><br></details>

<h4 id="Linux-上查找哪个线程cpu利用率最高？"><a href="#Linux-上查找哪个线程cpu利用率最高？" class="headerlink" title="Linux 上查找哪个线程cpu利用率最高？"></a>Linux 上查找哪个线程cpu利用率最高？</h4><details><br><br>top -H<br><br></details>

<h4 id="Linux-进程调度算法？"><a href="#Linux-进程调度算法？" class="headerlink" title="Linux 进程调度算法？"></a>Linux 进程调度算法？</h4><details><br><br>FCFS    先来先服务    按顺序<br><br>RR        时间片轮转    时间片轮转<br><br>HPF    优先级调度    按优先级调度<br><br>多级反馈调度            RR+HPF 对同一优先级采用时间片轮转<br><br>高响应比优先            等待时间+运行时间/运行时间<br><br></details>

<h4 id="Linux-线程模型？"><a href="#Linux-线程模型？" class="headerlink" title="Linux 线程模型？"></a>Linux 线程模型？</h4><details><br><br>Linux 并不存在单独的线程这样的结构，所谓线程不过是一些轻量级的进程，之所以满足线程的定义的是因为他们之间共享进程资源。<br><br></details>

<h4 id="Linux-buffer内存和cache内存？"><a href="#Linux-buffer内存和cache内存？" class="headerlink" title="Linux buffer内存和cache内存？"></a>Linux buffer内存和cache内存？</h4><details><br><br>两者都是RAM中的数据。简单来说，buffer是即将要被写入磁盘的，而cache是被从磁盘中读出来的。<br><br>缓存（cached）是把读取过的数据保存起来，重新读取时若命中（找到需要的数据）就不要去读硬盘了，若没有命中就读硬盘。<br><br>缓冲（buffers）是根据磁盘的读写设计的，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。<br><br></details>

<h4 id="操作系统内存管理机制？"><a href="#操作系统内存管理机制？" class="headerlink" title="操作系统内存管理机制？"></a>操作系统内存管理机制？</h4><details><br><br>分页式、分段式、段页式。<br><br></details>

<h4 id="用户态切换到内核态？"><a href="#用户态切换到内核态？" class="headerlink" title="用户态切换到内核态？"></a>用户态切换到内核态？</h4><details><br><br>系统调用、中断、异常。<br><br></details>

<h4 id="Ping命令？"><a href="#Ping命令？" class="headerlink" title="Ping命令？"></a>Ping命令？</h4><details><br><br>使用ICMP，在TCP/IP层。<br><br></details>

<h4 id="cat、chmod-、chown、cp、find-、head-、less-、ln-、locate、more-、mv、rm-、tail-、touch、vim、whereis-、which-、grep、wc、cd-、df-、du-、lsmkdir、-pwd-、rmdir-、ifconfig-、iptables-、netstat-、ping-、telnet、-date-、free-、kill-、ps-、rpm-、top-、yum-、bzip2-、gzip-、tar-、unzip？"><a href="#cat、chmod-、chown、cp、find-、head-、less-、ln-、locate、more-、mv、rm-、tail-、touch、vim、whereis-、which-、grep、wc、cd-、df-、du-、lsmkdir、-pwd-、rmdir-、ifconfig-、iptables-、netstat-、ping-、telnet、-date-、free-、kill-、ps-、rpm-、top-、yum-、bzip2-、gzip-、tar-、unzip？" class="headerlink" title="cat、chmod 、chown、cp、find 、head 、less 、ln 、locate、more 、mv、rm 、tail 、touch、vim、whereis 、which 、grep、wc、cd 、df 、du 、lsmkdir、 pwd 、rmdir 、ifconfig 、iptables 、netstat 、ping 、telnet、 date 、free 、kill 、ps 、rpm 、top 、yum 、bzip2 、gzip 、tar 、unzip？"></a>cat、chmod 、chown、cp、find 、head 、less 、ln 、locate、more 、mv、rm 、tail 、touch、vim、whereis 、which 、grep、wc、cd 、df 、du 、lsmkdir、 pwd 、rmdir 、ifconfig 、iptables 、netstat 、ping 、telnet、 date 、free 、kill 、ps 、rpm 、top 、yum 、bzip2 、gzip 、tar 、unzip？</h4><p><a href="#index"><strong>回到目录</strong></a></p>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a><span id="collection">Java</span></h2><h4 id="接口和抽象类的区别？"><a href="#接口和抽象类的区别？" class="headerlink" title="接口和抽象类的区别？"></a>接口和抽象类的区别？</h4><details><br><br>接口需要被实现、抽象类需要被集成。<br><br>接口只能声明方法、抽象类可以实现方法。<br><br></details>

<h4 id="Set接口与List有什么区别？"><a href="#Set接口与List有什么区别？" class="headerlink" title="Set接口与List有什么区别？"></a>Set接口与List有什么区别？</h4><details><br><br>有序、无序。<br><br>重复、不重复。<br><br></details>

<h4 id="Java集合的快速失败机制-“fail-fast”？"><a href="#Java集合的快速失败机制-“fail-fast”？" class="headerlink" title="Java集合的快速失败机制 “fail-fast”？"></a>Java集合的快速失败机制 “fail-fast”？</h4><details><br><br>当modCount != expectedModCount时，就会抛出该异常。但是在一开始的时候expectedModCount初始值默认等于modCount，为什么会出现modCount != expectedModCount，很明显expectedModCount在整个迭代过程除了一开始赋予初始值modCount外，并没有再发生改变，所以可能发生改变的就只有modCount，在前面关于ArrayList扩容机制的分析中，可以知道在ArrayList进行add，remove，clear等涉及到修改集合中的元素个数的操作时，modCount就会发生改变(modCount ++)，所以当另一个线程(并发修改)或者同一个线程遍历过程中，调用相关方法使集合的个数发生改变，就会使modCount发生变化，这样在checkForComodification方法中就会抛出ConcurrentModificationException异常。<br><br>类似的，hashMap中发生的原理也是一样的。<br><br></details>

<h4 id="Iterator-怎么使用？有什么特点？"><a href="#Iterator-怎么使用？有什么特点？" class="headerlink" title="Iterator 怎么使用？有什么特点？"></a>Iterator 怎么使用？有什么特点？</h4><details><br><br><code>iterator.hasNext()</code><br><br><code>iterator.next()</code><br><br><code>iterator.remove()</code><br><br></details>

<h4 id="如何边遍历边移除-Collection-中的元素？"><a href="#如何边遍历边移除-Collection-中的元素？" class="headerlink" title="如何边遍历边移除 Collection 中的元素？"></a>如何边遍历边移除 Collection 中的元素？</h4><details><br><br><code>iterator.remove()</code><br><br></details>

<h4 id="如何实现数组和-List-之间的转换？"><a href="#如何实现数组和-List-之间的转换？" class="headerlink" title="如何实现数组和 List 之间的转换？"></a>如何实现数组和 List 之间的转换？</h4><details><br><br><code>List&lt;String&gt; list=Arrays.asList(a);</code><br><br><code>.toArray()</code><br><br></details>

<h4 id="ArrayList-和-LinkedList-的区别是什么？"><a href="#ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h4><details><br><br>底层数组、双向链表。<br><br></details>

<h4 id="ArrayList-和-Vector-的区别是什么？"><a href="#ArrayList-和-Vector-的区别是什么？" class="headerlink" title="ArrayList 和 Vector 的区别是什么？"></a>ArrayList 和 Vector 的区别是什么？</h4><details><br><br>线程安全。<br><br></details>

<h4 id="多线程场景下如何使用-ArrayList？"><a href="#多线程场景下如何使用-ArrayList？" class="headerlink" title="多线程场景下如何使用 ArrayList？"></a>多线程场景下如何使用 ArrayList？</h4><details><br><br>Synchronized、CopyOnWrite。<br><br>在往集合中添加数据的时候，先拷贝存储的数组，然后添加元素到拷贝好的数组中，然后用现在的数组去替换成员变量的数组，写入时加锁。<br><br></details>

<h4 id="为什么-ArrayList-的-elementData-加上-transient-修饰？"><a href="#为什么-ArrayList-的-elementData-加上-transient-修饰？" class="headerlink" title="为什么 ArrayList 的 elementData 加上 transient 修饰？"></a>为什么 ArrayList 的 elementData 加上 transient 修饰？</h4><details><br><br><strong>transient阻止实例中那些用此关键字声明的变量持久化</strong><br><br><strong>elementData里面不是所有的元素都有数据，因为容量的问题，elementData里面有一些元素是空的，这种是没有必要序列化的</strong>。<strong>ArrayList的序列化和反序列化依赖writeObject和readObject方法来实现</strong>。<br><br></details>

<h4 id="说一下-HashSet-的实现原理？"><a href="#说一下-HashSet-的实现原理？" class="headerlink" title="说一下 HashSet 的实现原理？"></a>说一下 HashSet 的实现原理？</h4><details><br><br>HashSet是基于HashMap实现的，Value全部为同一个final修饰的Object。<br><br></details>

<h4 id="HashSet如何检查重复？HashSet是如何保证数据不可重复的？"><a href="#HashSet如何检查重复？HashSet是如何保证数据不可重复的？" class="headerlink" title="HashSet如何检查重复？HashSet是如何保证数据不可重复的？"></a>HashSet如何检查重复？HashSet是如何保证数据不可重复的？</h4><details><br><br><code>hashCode()+equals()</code><br><br></details>

<h4 id="BlockingQueue是什么？"><a href="#BlockingQueue是什么？" class="headerlink" title="BlockingQueue是什么？"></a>BlockingQueue是什么？</h4><details><br><br>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。<br><br>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒。<br><br></details>

<h4 id="在-Queue-中-offer-poll-peek-和-add-remove-element-有什么区别？"><a href="#在-Queue-中-offer-poll-peek-和-add-remove-element-有什么区别？" class="headerlink" title="在 Queue 中 offer()/poll()/peek()和 add()/remove()/element()有什么区别？"></a>在 Queue 中 offer()/poll()/peek()和 add()/remove()/element()有什么区别？</h4><details><br><br>但是如果想在一个满的队列中加入一个新元素，调用 add() 方法就会抛出一个 unchecked 异常，而调用 offer() 方法会返回 false。<br><br>但是peek()方法在队列为空时返回null，调用element()方法会抛出NoSuchElementException异常。<br><br>poll()和remove()都将移除并且返回对头，但是在poll()在队列为空时返回null，而remove()会抛出NoSuchElementException异常。<br><br></details>

<h4 id="说一下-HashMap-的实现原理？"><a href="#说一下-HashMap-的实现原理？" class="headerlink" title="说一下 HashMap 的实现原理？"></a>说一下 HashMap 的实现原理？</h4><details><br><br>底层数组加链表、线程不安全引发环形链表、可为null、初始化长度为16、8/64扩容、6缩小。<br><br>hashCode() hash()。<br><br></details>

<h4 id="HashMap在JDK1-7和JDK1-8中有哪些不同？HashMap的底层实现？"><a href="#HashMap在JDK1-7和JDK1-8中有哪些不同？HashMap的底层实现？" class="headerlink" title="HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现？"></a>HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现？</h4><details><br><br>1.7 数组加单链表，1.8 8/64红黑树。<br><br>1.7 头插法，1.8 尾插法。<br><br>1.7 扩容rehash，1.8 扩容看最高位。<br><br>HashMap在jdk1.7中采用头插入法，在扩容时会改变链表中元素原本的顺序，以至于在并发场景下导致链表成环的问题。而在jdk1.8中采用尾插入法，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。<br><br></details>

<h4 id="HashMap头插法有什么问题？"><a href="#HashMap头插法有什么问题？" class="headerlink" title="HashMap头插法有什么问题？"></a>HashMap头插法有什么问题？</h4><details><br><br>HashMap在jdk1.7中采用头插入法，在扩容时会改变链表中元素原本的顺序，以至于在并发场景下导致链表成环的问题。而在jdk1.8中采用尾插入法，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。<br><br></details>

<h4 id="HashMap的put方法的具体流程？"><a href="#HashMap的put方法的具体流程？" class="headerlink" title="HashMap的put方法的具体流程？"></a>HashMap的put方法的具体流程？</h4><h4 id="HashMap的扩容操作是怎么实现的？"><a href="#HashMap的扩容操作是怎么实现的？" class="headerlink" title="HashMap的扩容操作是怎么实现的？"></a>HashMap的扩容操作是怎么实现的？</h4><h4 id="HashMap是怎么解决哈希冲突的？"><a href="#HashMap是怎么解决哈希冲突的？" class="headerlink" title="HashMap是怎么解决哈希冲突的？"></a>HashMap是怎么解决哈希冲突的？</h4><h4 id="HashMap在多线程情况下会发生吗什么问题？如何发生的？"><a href="#HashMap在多线程情况下会发生吗什么问题？如何发生的？" class="headerlink" title="HashMap在多线程情况下会发生吗什么问题？如何发生的？"></a>HashMap在多线程情况下会发生吗什么问题？如何发生的？</h4><h4 id="HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？"><a href="#HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？" class="headerlink" title="HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？"></a>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h4><h4 id="HashMap-的长度为什么是2的幂次方？"><a href="#HashMap-的长度为什么是2的幂次方？" class="headerlink" title="HashMap 的长度为什么是2的幂次方？"></a>HashMap 的长度为什么是2的幂次方？</h4><h4 id="HashMap-和-ConcurrentHashMap-的区别？"><a href="#HashMap-和-ConcurrentHashMap-的区别？" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别？"></a>HashMap 和 ConcurrentHashMap 的区别？</h4><h4 id="ConcurrentHashMap-和-Hashtable-的区别？"><a href="#ConcurrentHashMap-和-Hashtable-的区别？" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别？"></a>ConcurrentHashMap 和 Hashtable 的区别？</h4><details><br><br>ConcurrentHashMap：1.7 Segment锁、1.8 CAS + Synchronized。<br><br>Hashtable：表锁。<br><br></details>

<h4 id="ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？"><a href="#ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？" class="headerlink" title="ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？"></a>ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</h4><details><br><br>1.8之前是Segment分段锁，1.8之后是Synchronized+CAS，Synchronized锁不为空Node头。<br><br></details>

<h4 id="JDK1-8-对方法去做了哪些改变？"><a href="#JDK1-8-对方法去做了哪些改变？" class="headerlink" title="JDK1.8 对方法去做了哪些改变？"></a>JDK1.8 对方法去做了哪些改变？</h4><details><br><br>1.7 采用永久代实现方法区。<br><br>1.8 之后移除了永久代（PermGen），替换为元空间（Metaspace）；<br>永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；<br>永久代中的 interned Strings 和 class static variables 转移到了 Java heap；<br><br></details>

<p><a href="#index"><strong>回到目录</strong></a></p>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a><span id="fbs">分布式</span></h2><h4 id="CAP理论？"><a href="#CAP理论？" class="headerlink" title="CAP理论？"></a>CAP理论？</h4><details><br><br>C 一致性、A 可用性、P 分区容错性。<br><br>如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，没有可用性不。<br><br>如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。<br><br>综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。<br><br></details>

<h4 id="缓存和数据库一致性解决方案？"><a href="#缓存和数据库一致性解决方案？" class="headerlink" title="缓存和数据库一致性解决方案？"></a>缓存和数据库一致性解决方案？</h4><details><br><br>延时删除Redis、更新数据库，确保最终一致性。<br><br></details>

<h4 id="分布式一致性算法？"><a href="#分布式一致性算法？" class="headerlink" title="分布式一致性算法？"></a>分布式一致性算法？</h4><details><br><br>Paxos、Raft。<br><br></details>

<h4 id="分布式事务如何解决？"><a href="#分布式事务如何解决？" class="headerlink" title="分布式事务如何解决？"></a>分布式事务如何解决？</h4><details><br><br> TCC，全局事务管理。<br><br></details>

<h4 id="一致性哈希是什么？"><a href="#一致性哈希是什么？" class="headerlink" title="一致性哈希是什么？"></a>一致性哈希是什么？</h4><details><br><br>首先求出服务器（节点）的哈希值，并将其配置到圆上。<br><br>然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。<br><br>然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。<br><br></details>

<h4 id="RPC是什么？"><a href="#RPC是什么？" class="headerlink" title="RPC是什么？"></a>RPC是什么？</h4><details><br><br>远程过程调用。<br><br></details>

<p><a href="#index"><strong>回到目录</strong></a></p>
<h2 id="必会设计模式"><a href="#必会设计模式" class="headerlink" title="必会设计模式"></a><span id="design">必会设计模式</span></h2><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Terminal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">implements</span> <span class="title">Terminal</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Use Phone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> <span class="keyword">implements</span> <span class="title">Terminal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Computer Use"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Terminal <span class="title">create</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">"Phone"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Phone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">"Computer"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Computer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Print!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterProxy</span> <span class="keyword">implements</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Outer outer;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterProxy</span><span class="params">(Outer outer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outer = outer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"pre"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pre();</span><br><span class="line">        outer.out();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单例模式-Double-Check"><a href="#单例模式-Double-Check" class="headerlink" title="单例模式/Double Check"></a>单例模式/Double Check</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态内部不稳定变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="comment">//隐藏构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//double check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单例模式-静态内部类"><a href="#单例模式-静态内部类" class="headerlink" title="单例模式/静态内部类"></a>单例模式/静态内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//隐藏构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">被观察者维护一个观察者列表，提供方法attach<span class="comment">()</span>将观察者添加到观察者列表。</span><br><span class="line">观察者拥有被观察者属性，生成时在构造函数里调用attach<span class="comment">()</span>注册到观察者列表。</span><br><span class="line">观察者拥有update<span class="comment">()</span>方法，每次被观察者状态改变时在set<span class="comment">()</span>方法中遍历列表调用他们的update<span class="comment">()</span>方法。</span><br></pre></td></tr></table></figure>
<p><a href="#index"><strong>回到目录</strong></a></p>
<h2 id="必会手撕排序算法"><a href="#必会手撕排序算法" class="headerlink" title="必会手撕排序算法"></a><span id="sort">必会手撕排序算法</span></h2><h4 id="冒泡排序-平均N-2-最好N-最差N-2-空间-1"><a href="#冒泡排序-平均N-2-最好N-最差N-2-空间-1" class="headerlink" title="冒泡排序 平均N^2 / 最好N / 最差N^2 / 空间 1"></a>冒泡排序 平均N^2 / 最好N / 最差N^2 / 空间 1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                nums[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="选择排序-平均N-2-最好N-2-最差N-2-空间-1"><a href="#选择排序-平均N-2-最好N-2-最差N-2-空间-1" class="headerlink" title="选择排序 平均N^2 / 最好N^2 / 最差N^2 / 空间 1"></a>选择排序 平均N^2 / 最好N^2 / 最差N^2 / 空间 1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> mini = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[mini]) mini = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[mini];</span><br><span class="line">        nums[mini] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入排序-平均N-2-最好N-最差N-2-空间-1"><a href="#插入排序-平均N-2-最好N-最差N-2-空间-1" class="headerlink" title="插入排序 平均N^2 / 最好N / 最差N^2 / 空间 1"></a>插入排序 平均N^2 / 最好N / 最差N^2 / 空间 1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速排序-平均NlogN-最好NlogN-最差N-2-空间-logN"><a href="#快速排序-平均NlogN-最好NlogN-最差N-2-空间-logN" class="headerlink" title="快速排序 平均NlogN / 最好NlogN / 最差N^2 / 空间 logN"></a>快速排序 平均NlogN / 最好NlogN / 最差N^2 / 空间 logN</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = partition(nums, start, end);</span><br><span class="line">    quickSort(nums, start, mid - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = nums[low];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; key &lt;= nums[high]) high--;<span class="comment">//注意等号 注意--</span></span><br><span class="line">        nums[low] = nums[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; key &gt;= nums[low]) low++;</span><br><span class="line">        nums[high] = nums[low];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nums[low] = key;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="归并排序-平均NlogN-最好NlogN-最差NlogN-空间-N"><a href="#归并排序-平均NlogN-最好NlogN-最差NlogN-空间-N" class="headerlink" title="归并排序 平均NlogN / 最好NlogN / 最差NlogN / 空间 N"></a>归并排序 平均NlogN / 最好NlogN / 最差NlogN / 空间 N</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(nums, low, mid);</span><br><span class="line">    mergeSort(nums, mid + <span class="number">1</span>, high);</span><br><span class="line">    merge(nums, low, mid, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> i = low, j = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">            temp[t++] = nums[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[t++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        temp[t++] = nums[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">        temp[t++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        nums[low++] = temp[t++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆排序-平均NlogN-最好NlogN-最差NlogN-空间-1"><a href="#堆排序-平均NlogN-最好NlogN-最差NlogN-空间-1" class="headerlink" title="堆排序 平均NlogN / 最好NlogN / 最差NlogN / 空间 1"></a>堆排序 平均NlogN / 最好NlogN / 最差NlogN / 空间 1</h4><p><a href="#index"><strong>回到目录</strong></a></p>
<h2 id="海量数据场景题"><a href="#海量数据场景题" class="headerlink" title="海量数据场景题"></a><span id="bd">海量数据场景题</span></h2><h4 id="海量日志数据，提取出某日访问百度次数最多的那个IP。"><a href="#海量日志数据，提取出某日访问百度次数最多的那个IP。" class="headerlink" title="海量日志数据，提取出某日访问百度次数最多的那个IP。"></a>海量日志数据，提取出某日访问百度次数最多的那个IP。</h4><details><br><br>IP是32位的，最多有个2^32个IP，4G内存。<br><br>Hash(IP)%1024分为1024个文件。<br><br></details> 

<h4 id="4G数据，2G内存如何排序？"><a href="#4G数据，2G内存如何排序？" class="headerlink" title="4G数据，2G内存如何排序？"></a>4G数据，2G内存如何排序？</h4><details><br><br>归并排序，外部排序。<br><br></details> 

<h4 id="搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。"><a href="#搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。" class="headerlink" title="搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。"></a>搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。</h4><details><br><br>Top K算法。<br><br></details> 

<h4 id="在2-5亿个整数中找出不重复的整数，注，内存不足以容纳这2-5亿个整数。"><a href="#在2-5亿个整数中找出不重复的整数，注，内存不足以容纳这2-5亿个整数。" class="headerlink" title="在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。"></a>在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</h4><details><br><br>2bit位图。<br><br></details> 

<h4 id="给40亿个不重复的unsigned-int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？"><a href="#给40亿个不重复的unsigned-int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？" class="headerlink" title="给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？"></a>给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</h4><details><br><br>按位分类，位图判断。<br><br></details> 

<p><a href="#index"><strong>回到目录</strong></a></p>
<h2 id="必刷剑指Offer-Leetcode100"><a href="#必刷剑指Offer-Leetcode100" class="headerlink" title="必刷剑指Offer + Leetcode100"></a><span id="al">必刷剑指Offer + Leetcode100</span></h2></div><div class="tags"><a href="/tags/面试/">面试</a></div><div class="post-nav"><a class="next" href="/post/java8new/">Java8 新特性</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://EricsmOOn.github.io/post/InterviewQuestionsJava/';
    this.page.identifier = 'post/InterviewQuestionsJava/';
    this.page.title = 'Java后端开发面试题汇总';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//ericsmoon.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//ericsmoon.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://ericsmoon.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="https://EricsmOOn.github.io"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/摘录/">摘录</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机/">计算机</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/GC/" style="font-size: 15px;">GC</a> <a href="/tags/年终总结/" style="font-size: 15px;">年终总结</a> <a href="/tags/JMM/" style="font-size: 15px;">JMM</a> <a href="/tags/AQS/" style="font-size: 15px;">AQS</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/MarkDown/" style="font-size: 15px;">MarkDown</a> <a href="/tags/文档/" style="font-size: 15px;">文档</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Java8/" style="font-size: 15px;">Java8</a> <a href="/tags/Lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/Stream/" style="font-size: 15px;">Stream</a> <a href="/tags/生活/" style="font-size: 15px;">生活</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/垃圾收集器/" style="font-size: 15px;">垃圾收集器</a> <a href="/tags/新枝/" style="font-size: 15px;">新枝</a> <a href="/tags/工作总结/" style="font-size: 15px;">工作总结</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/SSM/" style="font-size: 15px;">SSM</a> <a href="/tags/后台开发/" style="font-size: 15px;">后台开发</a> <a href="/tags/区块链/" style="font-size: 15px;">区块链</a> <a href="/tags/blockchain/" style="font-size: 15px;">blockchain</a> <a href="/tags/经济学/" style="font-size: 15px;">经济学</a> <a href="/tags/面经/" style="font-size: 15px;">面经</a> <a href="/tags/字节跳动/" style="font-size: 15px;">字节跳动</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/类加载机制/" style="font-size: 15px;">类加载机制</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/故事/" style="font-size: 15px;">故事</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/post/InterviewQuestionsJava/">Java后端开发面试题汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/post/java8new/">Java8 新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/post/ByteDanceInterview0118/">字节面经</a></li><li class="post-list-item"><a class="post-list-link" href="/post/DBMySQL/">MySQL 要点</a></li><li class="post-list-item"><a class="post-list-link" href="/post/Redis/">Redis 要点</a></li><li class="post-list-item"><a class="post-list-link" href="/post/JMM/">JMM(并发编程) 要点</a></li><li class="post-list-item"><a class="post-list-link" href="/post/x!nzhi/">新枝科技工作总结</a></li><li class="post-list-item"><a class="post-list-link" href="/post/JavaGC/">JVM 垃圾收集器</a></li><li class="post-list-item"><a class="post-list-link" href="/post/JVM/">JVM虚拟机</a></li><li class="post-list-item"><a class="post-list-link" href="/post/2019YearEndSummary/">2019年回溯&2020年方向</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Eric's Moon.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>